<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>4. The Kutta condition · GridPotentialFlow.jl</title><meta name="title" content="4. The Kutta condition · GridPotentialFlow.jl"/><meta property="og:title" content="4. The Kutta condition · GridPotentialFlow.jl"/><meta property="twitter:title" content="4. The Kutta condition · GridPotentialFlow.jl"/><meta name="description" content="Documentation for GridPotentialFlow.jl."/><meta property="og:description" content="Documentation for GridPotentialFlow.jl."/><meta property="twitter:description" content="Documentation for GridPotentialFlow.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GridPotentialFlow.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../1.-Basic-potential-flow-problem/">1. Basic potential flow problem</a></li><li><a class="tocitem" href="../2.-Potential-flow-with-an-impenetrable-surface/">2. Potential flow with an impenetrable surface</a></li><li><a class="tocitem" href="../3.-Non-uniqueness-and-discrete-circulation/">3. Non-uniqueness and discrete circulation</a></li><li class="is-active"><a class="tocitem" href>4. The Kutta condition</a><ul class="internal"><li><a class="tocitem" href="#Using-the-Kutta-condition-in-a-steady-state-problem"><span>Using the Kutta condition in a steady-state problem</span></a></li><li><a class="tocitem" href="#Using-the-Kutta-condition-to-set-a-new-vortex-element"><span>Using the Kutta condition to set a new vortex element</span></a></li><li><a class="tocitem" href="#Applying-more-than-one-Kutta-condition-on-a-body"><span>Applying more than one Kutta condition on a body</span></a></li></ul></li><li><a class="tocitem" href="../5.-Generalized-edge-conditions/">5. Generalized edge conditions</a></li><li><a class="tocitem" href="../6.-Force-and-the-added-mass/">6. Force and the added mass</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../public/">Public Documentation</a></li><li><a class="tocitem" href="../../private/">Private Documentation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>4. The Kutta condition</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>4. The Kutta condition</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/GridPotentialFlow.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/GridPotentialFlow.jl/blob/master/test/literate/4.-The-Kutta-condition.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="4.-The-Kutta-condition"><a class="docs-heading-anchor" href="#4.-The-Kutta-condition">4. The Kutta condition</a><a id="4.-The-Kutta-condition-1"></a><a class="docs-heading-anchor-permalink" href="#4.-The-Kutta-condition" title="Permalink"></a></h1><p>For surfaces that contain convex edges, the vortex sheet strength assumes a singular behavior in the vicinity of these edges, with a strength that depends on the interior angle of the edge: sharper edges have more singular behavior. In the discrete representation of the surface, edges are only approximately represented by the sudden disruptions of positions in clusters of adjacent points. The behavior in this discrete form is not quite singular, but the solution for the vortex sheet strength <span>$\mathfrak{f}$</span> nonetheless exhibits a large and rapid change of amplitude.</p><p>Let&#39;s illustrate this with the example of a flat plate. First create the grid.</p><pre><code class="language-julia hljs">Δx = 0.01
Lx = 2.0
xlim = (-Lx/2,Lx/2)
ylim = (-Lx/2,Lx/2)
g = PhysicalGrid(xlim,ylim,Δx);</code></pre><p>To create a potential flow model with flat plate, we use the <code>Plate</code> constructor from <code>RigidBodyTools.jl</code> and transform the body such that its angle of attack is <code>α</code>.</p><pre><code class="language-julia hljs">c = Lx/2 # chord length
α = -π/6 # angle of attack
plate = Plate(c,4*cellsize(g))
Tr = RigidTransform((0.0,0.0),α)
update_body!(plate,Tr)
pfb = PotentialFlowBody(plate);
model = VortexModel(g,bodies=[pfb]);</code></pre><p>To simulate the plate in a uniform flow, we have to set the <code>U∞</code> field of the vortex model to our desired value.</p><pre><code class="language-julia hljs">setU∞(model,(1.0,0.0))
sol = solve(model);</code></pre><p>By plotting a large number streamlines, we see how the flow accelerates as it tries to make its way around the sharp edges of the flat plate. In the continuous case, the velocity field would be singular at the edges.</p><pre><code class="language-julia hljs">plot(sol.ψ,g,levels=60);
plot!(plate,linecolor=:black,linewidth=2,xlabel=&quot;x&quot;,ylabel=&quot;y&quot;)</code></pre><img src="5d881eb6.svg" alt="Example block output"/><p>The continous vortex sheet strength shows similar singularities at the edges, and also in our discrete case, vortex sheet strength the indeed assumes an approximate singular behavior near those edges.</p><pre><code class="language-julia hljs">plot(sol.f,xlabel=&quot;body point index&quot;,ylabel=&quot;f&quot;,legend=false)</code></pre><img src="4b7ed9c2.svg" alt="Example block output"/><p>If we seek to eliminate this behavior, we must first have some means of exposing it. In fact, for any discretized surface, the essence of this nearly-singular behavior lies in the previously defined vector <span>$\mathfrak{f}_0$</span>, and all other bound vortex sheets associated with the same surface share the same nearly-singular behavior. Thus, we will use a multiplicative decomposition of the vortex sheet strength:</p><p class="math-container">\[\mathfrak{f} = \mathfrak{f}_0 \circ \tilde{\mathfrak{f}}\]</p><p>where <span>$\circ$</span> is the Hadamard product. This decomposed form isolates the singular behavior into <span>$\mathfrak{f}_0$</span>, and <span>$\tilde{\mathfrak{f}}$</span> is a relatively smoother vector of surface point data.</p><p>For our flat plate, we create <span>$\mathfrak{f}_0$</span> in the same way as we did on the previous page.</p><pre><code class="language-julia hljs">ones = ScalarData(length(plate))
ones .= 1.0
f₀ = model.system.ibp.Sfact\ones
plot(f₀)</code></pre><img src="0c6868ea.svg" alt="Example block output"/><p>Then we can plot the smooth <span>$\tilde{\mathfrak{f}}$</span> as follows.</p><pre><code class="language-julia hljs">plot(sol.f./f₀,xlabel=&quot;body point index&quot;,ylabel=&quot;f̃&quot;,legend=false)</code></pre><img src="00817aa3.svg" alt="Example block output"/><h2 id="Using-the-Kutta-condition-in-a-steady-state-problem"><a class="docs-heading-anchor" href="#Using-the-Kutta-condition-in-a-steady-state-problem">Using the Kutta condition in a steady-state problem</a><a id="Using-the-Kutta-condition-in-a-steady-state-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-Kutta-condition-in-a-steady-state-problem" title="Permalink"></a></h2><p>The Kutta condition corresponds to annihilating the nearly-singular behavior at a surface point. At such points, we will set the corresponding value of <span>$\tilde{\mathfrak{f}}$</span> to zero. Suppose we wish to enforce the Kutta condition at an edge corresponding to surface point <span>$k$</span>. The condition is</p><p class="math-container">\[\mathfrak{e}_{k}^{T} \tilde{\mathfrak{f}} = 0.\]</p><p>In the regularization operation on <span>$\mathfrak{f}$</span>, we can absorb <span>$\mathfrak{f}_0$</span> into <span>$\mathsf{R}$</span>, first noting that the Hadamard product can alternatively be written with the help of a diagonal matrix,</p><p class="math-container">\[\mathfrak{f} = \mathfrak{f}_0 \circ \tilde{\mathfrak{f}} = \mathsf{D}{\mathfrak{f}_0} \tilde{\mathfrak{f}}.\]</p><p>Then, we can define a re-scaled regularization operator,</p><p class="math-container">\[\mathsf{R}\mathfrak{f} = \mathsf{R} \mathsf{D}{\mathfrak{f}_0} \tilde{\mathfrak{f}} = \tilde{\mathsf{R}} \tilde{\mathfrak{f}}.\]</p><p>We will first take the steady-state approach to enforce the Kutta condition: allow the bound circulation to be set appropriately, with the implicit understanding that there is a starting vortex of equal and opposite circulation at infinity that preserves the Kelvin circulation theorem. The Lagrange multiplier for this constraint will not be <span>$\Gamma_b$</span>, but <span>$s_0$</span>.</p><p class="math-container">\[\begin{bmatrix}
\mathsf{L} &amp; \tilde{\mathsf{R}} &amp; 0\\
\mathsf{E} &amp;  0 &amp; \mathfrak{1}\\
0 &amp; \mathfrak{e}_{k}^{T} &amp; 0\\
\end{bmatrix} \begin{pmatrix} \mathsf{s} \\ \tilde{\mathfrak{f}} \\ s_0 \end{pmatrix} =
\begin{pmatrix} -\mathsf{w} \\ \mathfrak{s}&#39;_b \\ 0 \end{pmatrix}.\]</p><p>In <code>GridPotentialFlow.jl</code>, we create a regularized potential flow model by specifying the index of the regularized edges using the <code>edges</code> keyword when creating a <code>PotentialFlowBody</code>. In this case, we want to regularize the trailing edge, which is the last point of <code>Plate</code>, so its index is <code>length(plate)</code>.</p><pre><code class="language-julia hljs">pfb = PotentialFlowBody(plate,edges=[length(plate)])
model = VortexModel(g,bodies=[pfb],U∞=(1.0,0.0))
sol = solve(model);</code></pre><p>When there are no vortices present in the model, the package solves the above saddle point system and the solution is the steady state solution. Inspection of the streamlines shows that flow now indeed leaves the trailing edge smoothly.</p><pre><code class="language-julia hljs">plot(sol.ψ,g);
plot!(plate,linecolor=:black,linewidth=2,xlabel=&quot;x&quot;,ylabel=&quot;y&quot;)</code></pre><img src="869ed659.svg" alt="Example block output"/><p>By plotting the vortex sheet strength, we can see that by constraining the trailing edge point of <span>$\tilde{\mathfrak{f}}$</span>, its whole distribution is shifted upward compared to the unregularized case such that the last value equals zero.</p><pre><code class="language-julia hljs">plot(plot(sol.f,xlabel=&quot;body point index&quot;,ylabel=&quot;f&quot;,legend=false),plot(sol.f./f₀,xlabel=&quot;body point index&quot;,ylabel=&quot;f̃&quot;,legend=false),size=[800,300])</code></pre><img src="ae9193b1.svg" alt="Example block output"/><h2 id="Using-the-Kutta-condition-to-set-a-new-vortex-element"><a class="docs-heading-anchor" href="#Using-the-Kutta-condition-to-set-a-new-vortex-element">Using the Kutta condition to set a new vortex element</a><a id="Using-the-Kutta-condition-to-set-a-new-vortex-element-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-Kutta-condition-to-set-a-new-vortex-element" title="Permalink"></a></h2><p>In the previous section, we used the Kutta condition to set the bound circulation but did not explicitly create a new vortex element. This vortex element was assumed to lie at infinity so that its effect was negligible except insofar as it left equal but opposite circulation about the body.</p><p>In this section, we will create a new vortex element in the vicinity of the edge at which we are applying the Kutta condition. We will thus seek to establish the strength of this new element and to do so in such a manner that the overall circulation of the flow is conserved. Once the element is created, it will be allowed to advect with the local fluid velocity (minus its own contribution to this velocity).</p><p>Let us assume that the new vortex element (which we label with the subscript 1) is introduced at some point in physical space, and that its immersion into the Cartesian grid is described by a grid vector <span>$\mathsf{d}_1$</span> and that its strength (i.e., its circulation) is <span>$\delta\Gamma_1$</span>. Thus, the fluid vorticity after this new element&#39;s introduction can be written as</p><p class="math-container">\[\mathsf{w} + \delta\Gamma_1 \mathsf{d}_1.\]</p><p>The vector <span>$\mathsf{d}_1$</span> is the discrete Dirac delta function, identical (or similar) to the function that constitutes the regularization <span>$\mathsf{R}$</span> and interpolation <span>$\mathsf{E}$</span> matrices.</p><p>The Kutta condition is still to be enforced. We also seek to ensure that the total circulation is zero. (We are assuming that the flow has started from rest.) Let us denote the circulation of the existing fluid vorticity <span>$\mathsf{w}$</span> by</p><p class="math-container">\[\Gamma_{\mathsf{w}} = \Delta x \, \mathsf{1}^{T}\mathsf{w},\]</p><p>where <span>$\mathsf{1}$</span> is a grid vector of ones. Then, the circulation constraint is</p><p class="math-container">\[\mathfrak{1}^{T} \mathfrak{f} + \delta\Gamma_1 + \Gamma_{\mathsf{w}} = 0.\]</p><p>The circulation of the bound vortex sheet <span>$\mathfrak{f}$</span> can be re-written in terms of the smooth part of the sheet as <span>$\mathfrak{1}^{T} \mathfrak{f} = \mathfrak{f}_0 \tilde{\mathfrak{f}}$</span>.</p><p>With these two constraints, the overall saddle point system of equations is</p><p class="math-container">\[\begin{bmatrix}
\mathsf{L} &amp; \tilde{\mathsf{R}} &amp; 0 &amp; \mathsf{d}_1\\
\mathsf{E} &amp;  0 &amp; \mathfrak{1} &amp; 0\\
0 &amp; \mathfrak{e}_{k}^{T} &amp; 0 &amp; 0\\
0 &amp; \mathfrak{f}_{0}^{T} &amp; 0 &amp; 1
\end{bmatrix} \begin{pmatrix} \mathsf{s} \\ \tilde{\mathfrak{f}} \\ s_0 \\ \delta\Gamma_1 \end{pmatrix} =
\begin{pmatrix} -\mathsf{w} \\ \mathfrak{s}&#39;_b \\ 0 \\ -\Gamma_{\mathsf{w}} \end{pmatrix}.\]</p><p>To simulate this case for our flat plate, we need to insert a point vortex in the flow, preferably near the trailing edge. This situation corresponds to the flow right after impulsively starting a uniform flow around a flat plate and the point vortex now represents the starting vortex. We position the vortex behind and orthogonal the plate at a distance that is proportional to the convective length from the trailing edge. This position does not matter much here, but is of importance when we step in time and insert more point vortices every time step. Its strength can be set arbitrarily, because any vortices that are used for regularizing edges will be ignored when calculating <span>$\mathsf{w}$</span> in the right-hand side for the saddle-point system.</p><pre><code class="language-julia hljs">Δt = 1e-2
vTE = Vortex(plate.x[end]+3*Δt*cos(α+π/2),plate.y[end]+3*Δt*sin(α+π/2),0.0);</code></pre><p>We include the point vortex when we create our model. Because the package detects that there is a vortex in the model, it solves the unsteady saddle point system and the solution will include the strength for the new point vortex.</p><pre><code class="language-julia hljs">pfb = PotentialFlowBody(plate,edges=[length(plate)])
model = VortexModel(g,bodies=[pfb],vortices=[vTE],U∞=(1.0,0.0))
sol = solve(model);
plot(sol.ψ,g);
plot!(plate,linecolor=:black,linewidth=2)
scatter!(model.vortices.x,model.vortices.y,color=:black,markersize=2,xlabel=&quot;x&quot;,ylabel=&quot;y&quot;)</code></pre><img src="58aab9e3.svg" alt="Example block output"/><p>Note that the strength of the new point vortex is not automatically set when calling <code>solve</code> on the vortex model</p><p>Because of the proximity of the point vortex to the flat plate, <span>$\tilde{\mathfrak{f}}$</span> exhibits a quick variation in its value at the surface points that lie closest to the point vortex. The value at the trailing edge point itself is still constrained to zero.</p><pre><code class="language-julia hljs">plot(plot(sol.f,xlabel=&quot;body point index&quot;,ylabel=&quot;f&quot;,legend=false),plot(sol.f./f₀,xlabel=&quot;body point index&quot;,ylabel=&quot;f̃&quot;,legend=false),size=[800,300])</code></pre><img src="f8a46212.svg" alt="Example block output"/><h2 id="Applying-more-than-one-Kutta-condition-on-a-body"><a class="docs-heading-anchor" href="#Applying-more-than-one-Kutta-condition-on-a-body">Applying more than one Kutta condition on a body</a><a id="Applying-more-than-one-Kutta-condition-on-a-body-1"></a><a class="docs-heading-anchor-permalink" href="#Applying-more-than-one-Kutta-condition-on-a-body" title="Permalink"></a></h2><p>Suppose we wish to enforce the Kutta condition at two edges of the body–-at points <span>$k_{1}$</span> and <span>$k_{2}$</span>–-instead of one. Each such point has a constraint,</p><p class="math-container">\[\mathfrak{e}_{k_j}^{T} \tilde{\mathfrak{f}} = 0,\quad j = 1,2.\]</p><p>For two such constraints, we need two Lagrange multipliers: the strengths of two new vortices, <span>$\delta\Gamma_1$</span> and <span>$\delta\Gamma_2$</span>, immersed into the grid with <span>$\mathsf{d}_1$</span> and <span>$\mathsf{d}_2$</span>, respectively; and we still need the Lagrange multiplier <span>$s_0$</span> to ensure that Kelvin&#39;s circulation theorem is also enforced. The system in the previous section is thus easily generalized to the following:</p><p class="math-container">\[\begin{bmatrix}
\mathsf{L} &amp; \tilde{\mathsf{R}} &amp; 0 &amp; \mathsf{d}_1 &amp; \mathsf{d}_2\\
\mathsf{E} &amp;  0 &amp; \mathfrak{1} &amp; 0&amp; 0\\
0 &amp; \mathfrak{e}_{k_1}^{T} &amp; 0 &amp; 0 &amp; 0\\
0 &amp; \mathfrak{e}_{k_2}^{T} &amp; 0 &amp; 0 &amp; 0\\
0 &amp; \mathfrak{f}_{0}^{T} &amp; 0 &amp; 1 &amp; 1
\end{bmatrix} \begin{pmatrix} \mathsf{s} \\ \tilde{\mathfrak{f}} \\ s_0 \\ \delta\Gamma_1 \\ \delta\Gamma_2 \end{pmatrix} =
\begin{pmatrix} -\mathsf{w} \\ \mathfrak{s}&#39;_b \\ 0 \\ 0 \\ -\Gamma_{\mathsf{w}} \end{pmatrix}.\]</p><p>We now simulate this case again for our flat plate problem. This solution corresponds to the flow right after impulsively starting a uniform flow around a flat plate, but unlike the previous case, the flow now also separates at the leading edge.</p><p>We create two vortices, one near the leading edge and one near the trailing edge.</p><pre><code class="language-julia hljs">vLE = Vortex(plate.x[1]+3*Δt*c*cos(plate.α+π/2),plate.y[1]+3*Δt*c*sin(plate.α+π/2),0.0);
vTE = Vortex(plate.x[end]+3*Δt*cos(α+π/2),plate.y[end]+3*Δt*sin(α+π/2),0.0);</code></pre><p>The model now has two regularized edges, corresponding to the first body point and the last one.</p><pre><code class="language-julia hljs">pfb = PotentialFlowBody(plate,edges=[1,length(plate)])
model = VortexModel(g,bodies=[pfb],vortices=[vLE,vTE],U∞=(1.0,0.0))
sol = solve(model);
plot(sol.ψ,g);
plot!(plate,linecolor=:black,linewidth=2)
scatter!(model.vortices.x,model.vortices.y,markersize=2,xlabel=&quot;x&quot;,ylabel=&quot;y&quot;)</code></pre><img src="ff712e04.svg" alt="Example block output"/><pre><code class="language-julia hljs">plot(plot(sol.f,xlabel=&quot;body point index&quot;,ylabel=&quot;f&quot;,legend=false),plot(sol.f./f₀,xlabel=&quot;body point index&quot;,ylabel=&quot;f̃&quot;,legend=false),size=[800,300])</code></pre><img src="1f651eb4.svg" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../3.-Non-uniqueness-and-discrete-circulation/">« 3. Non-uniqueness and discrete circulation</a><a class="docs-footer-nextpage" href="../5.-Generalized-edge-conditions/">5. Generalized edge conditions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Saturday 21 September 2024 04:43">Saturday 21 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
