<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1. Basic potential flow problem · GridPotentialFlow.jl</title><meta name="title" content="1. Basic potential flow problem · GridPotentialFlow.jl"/><meta property="og:title" content="1. Basic potential flow problem · GridPotentialFlow.jl"/><meta property="twitter:title" content="1. Basic potential flow problem · GridPotentialFlow.jl"/><meta name="description" content="Documentation for GridPotentialFlow.jl."/><meta property="og:description" content="Documentation for GridPotentialFlow.jl."/><meta property="twitter:description" content="Documentation for GridPotentialFlow.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GridPotentialFlow.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>1. Basic potential flow problem</a><ul class="internal"><li><a class="tocitem" href="#Flow-around-a-point-vortex"><span>Flow around a point vortex</span></a></li><li><a class="tocitem" href="#Accuracy-of-the-discretized-Poisson-equation"><span>Accuracy of the discretized Poisson equation</span></a></li><li><a class="tocitem" href="#Corotating-point-vortices"><span>Corotating point vortices</span></a></li><li><a class="tocitem" href="#Corotating-vortex-patches"><span>Corotating vortex patches</span></a></li></ul></li><li><a class="tocitem" href="../2.-Potential-flow-with-an-impenetrable-surface/">2. Potential flow with an impenetrable surface</a></li><li><a class="tocitem" href="../3.-Non-uniqueness-and-discrete-circulation/">3. Non-uniqueness and discrete circulation</a></li><li><a class="tocitem" href="../4.-The-Kutta-condition/">4. The Kutta condition</a></li><li><a class="tocitem" href="../5.-Generalized-edge-conditions/">5. Generalized edge conditions</a></li><li><a class="tocitem" href="../6.-Force-and-the-added-mass/">6. Force and the added mass</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../public/">Public Documentation</a></li><li><a class="tocitem" href="../../private/">Private Documentation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>1. Basic potential flow problem</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>1. Basic potential flow problem</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/GridPotentialFlow.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/GridPotentialFlow.jl/blob/master/test/literate/1.-Basic-potential-flow-problem.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="1.-Basic-potential-flow-problem"><a class="docs-heading-anchor" href="#1.-Basic-potential-flow-problem">1. Basic potential flow problem</a><a id="1.-Basic-potential-flow-problem-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Basic-potential-flow-problem" title="Permalink"></a></h1><p>This part introduces how to solve the basic potential flow problem in this package. We consider here a staggered, Cartesian grid with uniform cell size and of infinite extent. The basic (unbounded) potential flow problem is expressed as</p><p class="math-container">\[\mathsf{Ls} = -\mathsf{w},\]</p><p>where <span>$\mathsf{L}$</span> is the discrete 5-point Laplacian operator, <span>$\mathsf{s}$</span> is the discrete streamfunction, and <span>$\mathsf{w}$</span> is the discrete vorticity. Following the vortex-in-cell approach, the discrete vorticity is obtained by regularizing the vorticity from the <span>$N_v$</span> vortex elements onto the cell vertices,</p><p class="math-container">\[\mathsf{w}_{i, j}=\sum_{q=1}^{N_{v}} \frac{1}{\Delta x} \Gamma_{v, q} d\left(\frac{\mathsf{x}_{i}-X_{q}}{\Delta x}\right) d\left(\frac{\mathsf{y}_{j}-Y_{q}}{\Delta x}\right)\]</p><p>where <span>$d$</span> is the <span>$M_{4}&#39;$</span> interpolation kernel, and <span>$(X_{q},Y_{q})$</span> and <span>$\Gamma_{v,q}$</span> are the position and strength of the <span>$q$</span>th vortex element.</p><h2 id="Flow-around-a-point-vortex"><a class="docs-heading-anchor" href="#Flow-around-a-point-vortex">Flow around a point vortex</a><a id="Flow-around-a-point-vortex-1"></a><a class="docs-heading-anchor-permalink" href="#Flow-around-a-point-vortex" title="Permalink"></a></h2><p>Now we will solve this discrete potential flow problem using <code>GridPotentialFlow.jl</code> to obtain the streamfunction field and velocity field around a single point vortex.</p><p>The first step in creating <em>any</em> <code>GridPotentialFlow</code> model is to create a <code>PhysicalGrid</code> to discretize the domain.</p><pre><code class="language-julia hljs">using GridPotentialFlow
Δx = 0.01
Lx = 2.0
xlim = (-Lx/2,Lx/2)
ylim = (-Lx/2,Lx/2)
g = PhysicalGrid(xlim,ylim,Δx,optimize=false);</code></pre><p>The second step is to create our point vortex using <code>Vortex</code>.</p><pre><code class="language-julia hljs">v = Vortex(0.0,0.0,1.0);</code></pre><p>Now we can create a <code>VortexModel</code> using the grid and an array containing the point vortex.</p><pre><code class="language-julia hljs">model = VortexModel(g,vortices=[v]);</code></pre><p>The discrete streamfunction <code>s</code> is then obtained using <code>streamfunction</code>.</p><pre><code class="language-julia hljs">s = streamfunction(model);
using Plots
plot(s,g,xlabel=&quot;x&quot;,ylabel=&quot;y&quot;)</code></pre><img src="9784cea2.svg" alt="Example block output"/><p>The function <code>streamfunction</code> returns a <code>Nodes</code> array. If we want to perform differential calculus operations this data, we can use the methods of the  <code>CartesianGrids</code> package. For example, we can easily obtain the velocity field from the streamfunction field using the <code>curl</code> operation.</p><pre><code class="language-julia hljs">q = curl(s);
plot(q,g,xlabel=&quot;x&quot;,ylabel=&quot;y&quot;)</code></pre><img src="ef6e2d5b.svg" alt="Example block output"/><h2 id="Accuracy-of-the-discretized-Poisson-equation"><a class="docs-heading-anchor" href="#Accuracy-of-the-discretized-Poisson-equation">Accuracy of the discretized Poisson equation</a><a id="Accuracy-of-the-discretized-Poisson-equation-1"></a><a class="docs-heading-anchor-permalink" href="#Accuracy-of-the-discretized-Poisson-equation" title="Permalink"></a></h2><p>To verify that the discretization technique of the Poisson equation is second-order accurate, we perform a mesh refinement analysis for a flow consisting of point vortices of random strenght that are randomly positioned on the lower-left quadrant of a square domain.</p><p>The error is calculated by comparing the numerically calculated streamfunction field with the exact solution for the streamfunction field. We therefore need a function to calculate the exact streamfunction.</p><pre><code class="language-julia hljs">function ψ_vortex!(ψ::Nodes{Dual,nx,ny},vortex::Vortex,g::PhysicalGrid) where {nx,ny}
    x,y = coordinates(ψ,g)
    for i in 2:nx-1, j in 2:ny-1
        r = sqrt((x[i]-vortex.x)^2+(y[j]-vortex.y)^2)
        ψ[i,j] = ψ_vortex(r,vortex.Γ)
    end
end

function ψ_vortex(r::Real,Γ::Real)
    return -Γ/(2π)*log(r)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ψ_vortex (generic function with 1 method)</code></pre><p>We create four vortices with random strenghts, randomly positioned in the lower-left quadrant of the domain.</p><pre><code class="language-julia hljs">nv = 4;
vl = Vortex.(-Lx/4 .+ 0.4*Lx*(rand(nv).-0.5),-Lx/4 .+ 0.4*Lx*(rand(nv).-0.5),0.5*rand(nv).+0.5);</code></pre><p>Next, we create a series of grids, with each grid doubling the number of grid points of the previous grid in each direction.</p><pre><code class="language-julia hljs">grids = [PhysicalGrid(xlim,ylim,Lx/(nx-2),optimize=false) for nx in [2^p for p in 5:9]];</code></pre><p>The error is calculated as <span>$\epsilon = \Vert \psi(\mathsf{x},\mathsf{y})/\Delta x - \mathsf{s} \Vert_2 / \Vert \mathsf{s} \Vert_2$</span>, for which we use the <code>norm</code> function.</p><pre><code class="language-julia hljs">using LinearAlgebra: norm</code></pre><p>We now loop over the grids and calculate the error.</p><pre><code class="language-julia hljs">errors = []
gridspacings = []
for g in grids
    # LGF
    local model = VortexModel(g,vortices=vl)
    s_lgf = streamfunction(model);

    # Exact solution
    s_exact = Nodes(Dual,size(g))
    s_temp = Nodes(Dual,size(g))
    for v in vl
        ψ_vortex!(s_temp,v,g)
        s_exact += s_temp
    end

    # Bring to same reference level. A constant value can be added/subtracted to any potential flow solution
    s_lgf .-= s_lgf[g.I0[1],2];
    s_exact .-= s_exact[g.I0[1],2];

    error = s_lgf-s_exact
    idx = g.I0[1] + 1 : g.N[1] - 1 # Only look at top right corner
    push!(errors,norm(error[idx,idx])/norm(s_lgf[idx,idx]))
    push!(gridspacings,g.Δx)
end</code></pre><p>And finally, we create a log-log plot of the error versus the grid spacing.</p><pre><code class="language-julia hljs">firstorder=(errors[end]/gridspacings[end].*gridspacings).^1
secondorder=(sqrt(errors[end])/gridspacings[end].*gridspacings).^2
p=plot(gridspacings,errors,xaxis=:log,yaxis=:log,marker=:circle,lab=&quot;error&quot;,xlabel=&quot;dx&quot;,legend=:bottomright,title=&quot;Error&quot;)
plot!(gridspacings,firstorder,lab=&quot;1st order&quot;,linestyle=:dot,linecolor=:black)
plot!(gridspacings,secondorder,lab=&quot;2nd order&quot;,linestyle=:dash,linecolor=:black)</code></pre><img src="7e6bac86.svg" alt="Example block output"/><h2 id="Corotating-point-vortices"><a class="docs-heading-anchor" href="#Corotating-point-vortices">Corotating point vortices</a><a id="Corotating-point-vortices-1"></a><a class="docs-heading-anchor-permalink" href="#Corotating-point-vortices" title="Permalink"></a></h2><p>Now we will try advancing a vortex model in time. The simplest unsteady vortex model consists of two point vortices. When both point vortices have the same strength, they will rotate around each other on a trajectory that is easy to describe analytically. In this example, we will compare the analytical and simulated trajectories during one revolution.</p><p>We create two vortices at a distance <span>$d$</span> from each other and give them a strength <span>$\Gamma$</span></p><pre><code class="language-julia hljs">d = Lx/2
Γ = 1
v1 = Vortex(d/2,0.0,Γ);
v2 = Vortex(-d/2,0.0,Γ);</code></pre><p>We can analytically determine the time <span>$T$</span> it takes for these vortices to complete one revolution around their centroid.</p><pre><code class="language-julia hljs">Vθ = Γ/(2*π*d); # Analytical tangential velocity
T = π*d/Vθ # Analytical period</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">19.739208802178716</code></pre><p>Let&#39;s now create a vortex model with the two point vortices.</p><pre><code class="language-julia hljs">model = VortexModel(g,vortices=[v1,v2]);</code></pre><p>If we update the positions of the point vortices repeatedly to simulate the model advancing in time from <span>$t=0$</span> to <span>$t=T$</span>, we can check if they end up again at their original positions.</p><pre><code class="language-julia hljs">tspan = (0.0,T);</code></pre><p>To step in time, we can simply update the position of the <span>$q$</span>th vortex as <span>$X^{n+1}_q = X^{n}_q + Δt Ẋ^{n}_q$</span> (forward Euler) in a for-loop. Alternatively, we can make use of the <code>OrdinaryDiffEq.jl</code> package and use, for example, their fourth-order Runge-Kutta time stepping scheme.</p><pre><code class="language-julia hljs">import OrdinaryDiffEq

#= To construct the `ODEProblem` from this package, we will have to provide a right-hand side function that computes the velocities $Ẋ$ of the vortices, which is the local flow velocity at their positions. These velocities are obtained using `vortexvelocities`, which regularizes the vorticity to the grid, solves the potential flow system, and interpolates the velocities from the grid to the vortex locations as

$\left(U_{q}, V_{q}\right)=\sum_{i, j} \mathsf{v}_{i j} d\left(\frac{\mathsf{x}_{i}-X_{q}}{\Delta x}\right)\left(\frac{\mathsf{y}_{j}-Y_{q}}{\Delta x}\right),$

where $v$ is the velocity field on the nodes.
=#

function rhs(X,model,t)
    setvortexpositions!(model,X)
    Ẋ = vortexvelocities!(model)
    return Ẋ
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">rhs (generic function with 1 method)</code></pre><p>We finally create the problem and solve it with a fourth-order Runge-Kutta time stepping scheme.</p><pre><code class="language-julia hljs">X = getvortexpositions(model)
prob = OrdinaryDiffEq.ODEProblem(rhs,X,tspan,model);
sol = OrdinaryDiffEq.solve(prob,dt=0.1,OrdinaryDiffEq.RK4(),dense=false,adaptive=false);</code></pre><p>When we plot the x- and y-position versus time of the first vortex, we see it completed one revolution.</p><pre><code class="language-julia hljs">plot(sol.t,map(s-&gt;s.u[1],sol.u),xlabel=&#39;t&#39;,label=&quot;x₁&quot;)
plot!(sol.t,map(s-&gt;s.v[1],sol.u),label=&quot;y₁&quot;)</code></pre><img src="74b70ca5.svg" alt="Example block output"/><h2 id="Corotating-vortex-patches"><a class="docs-heading-anchor" href="#Corotating-vortex-patches">Corotating vortex patches</a><a id="Corotating-vortex-patches-1"></a><a class="docs-heading-anchor-permalink" href="#Corotating-vortex-patches" title="Permalink"></a></h2><p>A more complex example is the evolution of two circular regions of spatially uniform vorticity that have an equal radius <span>$r_0$</span> and circulation <span>$\Gamma$</span>, and whose centers are separated by a distance <span>$d_0$</span>. If <span>$r_0/d_0$</span> is small enough, these two vortex patches can be regarded as two point vortices with the same circulation and separation. We therefore assume the period of this system is approximately the same as the the period for the point vortices case.</p><p>We discretize the vortex patches with point vortices arranged on concentric rings using the following function.</p><pre><code class="language-julia hljs">function vortexpatch!(vort,xc,yc,Γ,radius,nring)
    Δr = radius/(nring-1/2)
    dΓ = Γ/(1+8*nring*(nring-1)/2)
    push!(vort,Vortex(xc,yc,dΓ))
    for ir in 1:nring-1
        nθ = 8*ir
        for j = 0:nθ-1
            push!(vort,Vortex(xc + ir*Δr*cos(2π*j/nθ),yc + ir*Δr*sin(2π*j/nθ),dΓ))
        end
    end
    return vort
end

vortexpatch(xc,yc,Γ,radius,nring) = vortexpatch!(Vortex[],xc,yc,Γ,radius,nring)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">vortexpatch (generic function with 1 method)</code></pre><p>We will simulate two cases with different values for <span>$r_0/d_0$</span>, the ratio of the vortex patch radius to the distance between them.</p><pre><code class="language-julia hljs">d0 = d
anims = []
for r0 in [0.2*d0, 0.4*d0]
    vortices = vcat(vortexpatch(0.0,0.0+d0/2,Γ,r0,10),vortexpatch(0.0,0.0-d0/2,Γ,r0,10));
    vortexcolors = vcat(fill(:blue,length(vortices)÷2),fill(:red,length(vortices)÷2));
    local model = VortexModel(g,vortices=vortices);
    local X = getvortexpositions(model)
    local prob = OrdinaryDiffEq.ODEProblem(rhs,X,tspan,model);
    local sol = OrdinaryDiffEq.solve(prob,dt=0.1,OrdinaryDiffEq.RK4(),dense=false,adaptive=false);
    anim = @animate for i=1:length(sol.t)-1
        plot(xlims=xlim,ylims=ylim,ratio=:equal,legend=:none,title=&quot;r0/d0 = $(r0/d0)&quot;)
        scatter!(sol.u[i].u,sol.u[i].v,markerstrokewidth=0,markersize=3,color=vortexcolors)
    end
    push!(anims,anim)
end

gif(anims[1])</code></pre><img src="dc9ca30d.gif" alt="Example block output"/><p>If the ratio <span>$r_0/d_0$</span> is big enough, the two vortex patches merge with eachother, a result that has been widely reported in literature <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><pre><code class="language-julia hljs">gif(anims[2])</code></pre><img src="c01d7e9a.gif" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Eldredge J. D. (2019) &quot;Mathematical  Modeling  of  Unsteady  Inviscid  Flows, Interdisciplinary Applied Mathematics&quot; <em>Springer</em>, vol. 50.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../2.-Potential-flow-with-an-impenetrable-surface/">2. Potential flow with an impenetrable surface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Saturday 21 September 2024 04:43">Saturday 21 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
