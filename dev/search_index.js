var documenterSearchIndex = {"docs":
[{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"EditURL = \"<unknown>/literate/1.-Basic-potential-flow-problem.jl\"","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/#.-Basic-potential-flow-problem","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"","category":"section"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"This part introduces how to solve the basic potential flow problem in this package. We consider here a staggered, Cartesian grid with uniform cell size and of infinite extent. The basic (unbounded) potential flow problem is expressed as","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"mathsfLs = -mathsfw","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"where mathsfL is the discrete 5-point Laplacian operator, mathsfs is the discrete streamfunction, and mathsfw is the discrete vorticity. Following the vortex-in-cell approach, the discrete vorticity is obtained by regularizing the vorticity from the N_v vortex elements onto the cell vertices,","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"mathsfw_i j=sum_q=1^N_v frac1Delta x Gamma_v q dleft(fracmathsfx_i-X_qDelta xright) dleft(fracmathsfy_j-Y_qDelta xright)","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"where d is the M_4 interpolation kernel, and (X_qY_q) and Gamma_vq are the position and strength of the qth vortex element.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/#Flow-around-a-point-vortex","page":"1. Basic potential flow problem","title":"Flow around a point vortex","text":"","category":"section"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"Now we will solve this discrete potential flow problem using GridPotentialFlow.jl to obtain the streamfunction field and velocity field around a single point vortex.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"The first step in creating any GridPotentialFlow model is to create a PhysicalGrid to discretize the domain.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"using GridPotentialFlow\nΔx = 0.01\nLx = 2.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx);\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"The second step is to create our point vortex using Vortex.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"v = Vortex(0.0,0.0,1.0);\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"Now we can create a VortexModel using the grid and an array containing the point vortex.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"model = VortexModel(g,vortices=[v]);\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"The discrete streamfunction s is then obtained using streamfunction.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"s = streamfunction(model);\nusing Plots\nplot(s,g,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"The function streamfunction returns a Nodes array. If we want to perform differential calculus operations this data, we can use the methods of the  CartesianGrids package. For example, we can easily obtain the velocity field from the streamfunction field using the curl operation.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"q = curl(s);\nplot(q,g,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/#Accuracy-of-the-discretized-Poisson-equation","page":"1. Basic potential flow problem","title":"Accuracy of the discretized Poisson equation","text":"","category":"section"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"To verify that the discretization technique of the Poisson equation is second-order accurate, we perform a mesh refinement analysis for a flow consisting of point vortices of random strenght that are randomly positioned on the lower-left quadrant of a square domain.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"The error is calculated by comparing the numerically calculated streamfunction field with the exact solution for the streamfunction field. We therefore need a function to calculate the exact streamfunction.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"function ψ_vortex!(ψ::Nodes{Dual,nx,ny},vortex::Vortex,g::PhysicalGrid) where {nx,ny}\n    x,y = coordinates(ψ,g)\n    for i in 2:nx-1, j in 2:ny-1\n        r = sqrt((x[i]-vortex.x)^2+(y[j]-vortex.y)^2)\n        ψ[i,j] = ψ_vortex(r,vortex.Γ)\n    end\nend\n\nfunction ψ_vortex(r::Real,Γ::Real)\n    return -Γ/(2π)*log(r)\nend","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"We create four vortices with random strenghts, randomly positioned in the lower-left quadrant of the domain.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"nv = 4;\nvl = Vortex.(-Lx/4 .+ 0.4*Lx*(rand(nv).-0.5),-Lx/4 .+ 0.4*Lx*(rand(nv).-0.5),0.5*rand(nv).+0.5);\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"Next, we create a series of grids, with each grid doubling the number of grid points of the previous grid in each direction.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"grids = [PhysicalGrid(xlim,ylim,Lx/(nx-2)) for nx in [2^p for p in 5:9]];\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"The error is calculated as epsilon = Vert psi(mathsfxmathsfy)Delta x - mathsfs Vert_2  Vert mathsfs Vert_2, for which we use the norm function.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"using LinearAlgebra: norm","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"We now loop over the grids and calculate the error.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"errors = []\ngridspacings = []\nfor g in grids\n    # LGF\n    local model = VortexModel(g,vortices=vl)\n    s_lgf = streamfunction(model);\n\n    # Exact solution\n    s_exact = Nodes(Dual,size(g))\n    s_temp = Nodes(Dual,size(g))\n    for v in vl\n        ψ_vortex!(s_temp,v,g)\n        s_exact += s_temp\n    end\n\n    # Bring to same reference level. A constant value can be added/subtracted to any potential flow solution\n    s_lgf .-= s_lgf[g.I0[1],2];\n    s_exact .-= s_exact[g.I0[1],2];\n\n    error = s_lgf-s_exact\n    idx = g.I0[1] + 1 : g.N[1] - 1 # Only look at top right corner\n    push!(errors,norm(error[idx,idx])/norm(s_lgf[idx,idx]))\n    push!(gridspacings,g.Δx)\nend","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"And finally, we create a log-log plot of the error versus the grid spacing.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"firstorder=(errors[end]/gridspacings[end].*gridspacings).^1\nsecondorder=(sqrt(errors[end])/gridspacings[end].*gridspacings).^2\np=plot(gridspacings,errors,xaxis=:log,yaxis=:log,marker=:circle,lab=\"error\",xlabel=\"dx\",legend=:bottomright,title=\"Error\")\nplot!(gridspacings,firstorder,lab=\"1st order\",linestyle=:dot,linecolor=:black)\nplot!(gridspacings,secondorder,lab=\"2nd order\",linestyle=:dash,linecolor=:black)","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/#Corotating-point-vortices","page":"1. Basic potential flow problem","title":"Corotating point vortices","text":"","category":"section"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"Now we will try advancing a vortex model in time. The simplest unsteady vortex model consists of two point vortices. When both point vortices have the same strength, they will rotate around each other on a trajectory that is easy to describe analytically. In this example, we will compare the analytical and simulated trajectories during one revolution.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"We create two vortices at a distance d from each other and give them a strength Gamma","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"d = Lx/2\nΓ = 1\nv1 = Vortex(d/2,0.0,Γ);\nv2 = Vortex(-d/2,0.0,Γ);\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"We can analytically determine the time T it takes for these vortices to complete one revolution around their centroid.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"Vθ = Γ/(2*π*d); # Analytical tangential velocity\nT = π*d/Vθ # Analytical period","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"Let's now create a vortex model with the two point vortices.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"model = VortexModel(g,vortices=[v1,v2]);\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"If we update the positions of the point vortices repeatedly to simulate the model advancing in time from t=0 to t=T, we can check if they end up again at their original positions.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"tspan = (0.0,T);\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"To step in time, we can simply update the position of the qth vortex as X^n+1_q = X^n_q + Δt X^n_q (forward Euler) in a for-loop. Alternatively, we can make use of the OrdinaryDiffEq.jl package and use, for example, their fourth-order Runge-Kutta time stepping scheme.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"import OrdinaryDiffEq\n\n#= To construct the `ODEProblem` from this package, we will have to provide a right-hand side function that computes the velocities $Ẋ$ of the vortices, which is the local flow velocity at their positions. These velocities are obtained using `vortexvelocities`, which regularizes the vorticity to the grid, solves the potential flow system, and interpolates the velocities from the grid to the vortex locations as\n\n$\\left(U_{q}, V_{q}\\right)=\\sum_{i, j} \\mathsf{v}_{i j} d\\left(\\frac{\\mathsf{x}_{i}-X_{q}}{\\Delta x}\\right)\\left(\\frac{\\mathsf{y}_{j}-Y_{q}}{\\Delta x}\\right),$\n\nwhere $v$ is the velocity field on the nodes.\n=#\n\nfunction rhs(X,model,t)\n    setvortexpositions!(model,X)\n    Ẋ = vortexvelocities!(model)\n    return Ẋ\nend","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"We finally create the problem and solve it with a fourth-order Runge-Kutta time stepping scheme.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"X = getvortexpositions(model)\nprob = OrdinaryDiffEq.ODEProblem(rhs,X,tspan,model);\nsol = OrdinaryDiffEq.solve(prob,dt=0.1,OrdinaryDiffEq.RK4(),dense=false,adaptive=false);\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"When we plot the x- and y-position versus time of the first vortex, we see it completed one revolution.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"plot(sol.t,map(s->s.u[1],sol.u),xlabel='t',label=\"x₁\")\nplot!(sol.t,map(s->s.v[1],sol.u),label=\"y₁\")","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/#Corotating-vortex-patches","page":"1. Basic potential flow problem","title":"Corotating vortex patches","text":"","category":"section"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"A more complex example is the evolution of two circular regions of spatially uniform vorticity that have an equal radius r_0 and circulation Gamma, and whose centers are separated by a distance d_0. If r_0d_0 is small enough, these two vortex patches can be regarded as two point vortices with the same circulation and separation. We therefore assume the period of this system is approximately the same as the the period for the point vortices case.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"xlim = (-2,2);\nylim = (-2,2);\nΔx = 0.05;\ng = PhysicalGrid(xlim,ylim,Δx);","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"We discretize the vortex patches with point vortices arranged on concentric rings using the following function.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"function vortexpatch!(vort,xc,yc,Γ,radius,nring)\n    Δr = radius/(nring-1/2)\n    dΓ = Γ/(1+8*nring*(nring-1)/2)\n    push!(vort,Vortex(xc,yc,dΓ))\n    for ir in 1:nring-1\n        nθ = 8*ir\n        for j = 0:nθ-1\n            push!(vort,Vortex(xc + ir*Δr*cos(2π*j/nθ),yc + ir*Δr*sin(2π*j/nθ),dΓ))\n        end\n    end\n    return vort\nend\n\nvortexpatch(xc,yc,Γ,radius,nring) = vortexpatch!(Vortex[],xc,yc,Γ,radius,nring)","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"We will simulate two cases with different values for r_0d_0, the ratio of the vortex patch radius to the distance between them.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"d0 = d\nanims = []\nfor r0 in [0.2*d0, 0.4*d0]\n    vortices = vcat(vortexpatch(0.0,0.0+d0/2,Γ,r0,10),vortexpatch(0.0,0.0-d0/2,Γ,r0,10));\n    vortexcolors = vcat(fill(:blue,length(vortices)÷2),fill(:red,length(vortices)÷2));\n    local model = VortexModel(g,vortices=vortices);\n    local X = getvortexpositions(model)\n    local prob = OrdinaryDiffEq.ODEProblem(rhs,X,tspan,model);\n    local sol = OrdinaryDiffEq.solve(prob,dt=0.1,OrdinaryDiffEq.RK4(),dense=false,adaptive=false);\n    anim = @animate for i=1:length(sol.t)-1\n        plot(xlims=xlim,ylims=ylim,ratio=:equal,legend=:none,title=\"r0/d0 = $(r0/d0)\")\n        scatter!(sol.u[i].u,sol.u[i].v,markerstrokewidth=0,markersize=3,color=vortexcolors)\n    end\n    push!(anims,anim)\nend\n\ngif(anims[1])","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"If the ratio r_0d_0 is big enough, the two vortex patches merge with eachother, a result that has been widely reported in literature [1].","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"gif(anims[2])","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"[1]: Eldredge J. D. (2019) \"Mathematical  Modeling  of  Unsteady  Inviscid  Flows, Interdisciplinary Applied Mathematics\" Springer, vol. 50.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"private/#Private-Documentation","page":"Private Documentation","title":"Private Documentation","text":"","category":"section"},{"location":"private/","page":"Private Documentation","title":"Private Documentation","text":"Documentation for GridPotentialFlow.jl's private interface.","category":"page"},{"location":"private/","page":"Private Documentation","title":"Private Documentation","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"private/#Contents","page":"Private Documentation","title":"Contents","text":"","category":"section"},{"location":"private/","page":"Private Documentation","title":"Private Documentation","text":"Pages = [\"private.md\"]","category":"page"},{"location":"private/#Index","page":"Private Documentation","title":"Index","text":"","category":"section"},{"location":"private/","page":"Private Documentation","title":"Private Documentation","text":"Pages = [\"private.md\"]","category":"page"},{"location":"private/#Private-Interface","page":"Private Documentation","title":"Private Interface","text":"","category":"section"},{"location":"private/","page":"Private Documentation","title":"Private Documentation","text":"Modules = [GridPotentialFlow]\nPublic = false","category":"page"},{"location":"private/#GridPotentialFlow.ConstrainedIBPoisson","page":"Private Documentation","title":"GridPotentialFlow.ConstrainedIBPoisson","text":"struct ConstrainedIBPoisson{Nb, TU, TF} <: GridPotentialFlow.AbstractPotentialFlowSystem{TU}\n\nDefines an immersed boundary Poisson system with a single type of constraints on the bound vortex sheet strength.\n\nFields\n\nibp::GridPotentialFlow.IBPoisson{TU,TF} where TF where TU\nibp: Immersed boundary poisson inner system that solves for the streamfunction and bound vortex sheet strength, given a streamfunction boundary condition on immersed boundary points.\nB₁ᵀ₂cols::Array{TF,1} where TF\nB₁ᵀ₂cols: Columns of the second partition of the B₁ᵀ matrix for the outer system.\nB₂₂rows::Array{TF,1} where TF\nB₂₂rows: Rows of the second partition of the B₂ matrix for the outer system.\nSoutfact::Union{Float64, LinearAlgebra.Factorization}\nSoutfact: Factorized version of the Schur complement for the outer system.\n_f_buf::Any\nBuffers\n_ψ₀_buf::Array{Float64,1}\n_sol_buf::GridPotentialFlow.IBPoissonSolution{TU,TF} where TF where TU\n\n\n\n\n\n","category":"type"},{"location":"private/#GridPotentialFlow.IBPoisson","page":"Private Documentation","title":"GridPotentialFlow.IBPoisson","text":"struct IBPoisson{TU, TF} <: GridPotentialFlow.AbstractPotentialFlowSystem{TU}\n\nDefines an immersed boundary Poisson system that solves for the streamfunction and bound vortex sheet strength, given a streamfunction boundary condition on immersed boundary points.\n\nFields\n\nL::CartesianGrids.Laplacian\nL: Discrete Laplacian.\nR::RegularizationMatrix{TU,TF} where TF where TU\nR: Regularization operator.\nE::InterpolationMatrix{TU,TF} where TF where TU\nE: Interpolation operator.\nSfact::LinearAlgebra.LU\nSfact: factorized version of the Schur complement.\n_A⁻¹r₁::Any\nBuffers\n_B₁ᵀf::Any\n_f_buf::Any\n\n\n\n\n\n","category":"type"},{"location":"private/#GridPotentialFlow.SteadyRegularizedIBPoisson","page":"Private Documentation","title":"GridPotentialFlow.SteadyRegularizedIBPoisson","text":"struct SteadyRegularizedIBPoisson{Nb, Ne, TU, TF} <: GridPotentialFlow.AbstractPotentialFlowSystem{TU}\n\nDefines an immersed boundary Poisson system with constraints on the bound vortex sheet strength that regularize up to one edge per body.\n\nFields\n\ncibp::GridPotentialFlow.ConstrainedIBPoisson{Nb,TU,TF} where TF where TU where Nb\ncibp: Constrained immersed boundary Poisson system.\none_vec::Array{TF,1} where TF\none_vec: Array of vectors with the i-th entry of the j-th vector equal to one if i is an index of the points that belong to the j-th body and zero otherwise.\ne_vec::Array{TF,1} where TF\ne_vec: Array of unit vectors with the inner product of the k-th unit vector and vortex sheet strength equal to the value of the vortex sheet strength at the k-th edge.\nf₀::Any\nf₀: Unregularized bound vortex sheet strength due to a uniform unit boundary condition for the streamfunction on all immersed bodies.\nf₀_vec::Array{TF,1} where TF\nf₀_vec: Array of unregularized bound vortex sheet strengths with the i-th entry the bound vortex sheet strength due to a uniform unit boundary condition for the streamfunction on the i-th immersed body and zero everywhere else.\n\n\n\n\n\n","category":"type"},{"location":"private/#GridPotentialFlow.UnsteadyRegularizedIBPoisson","page":"Private Documentation","title":"GridPotentialFlow.UnsteadyRegularizedIBPoisson","text":"struct UnsteadyRegularizedIBPoisson{Nb, Ne, TU, TF} <: GridPotentialFlow.AbstractPotentialFlowSystem{TU}\n\nDefines an immersed boundary Poisson system that, in addition to solving for the streamfunction and bound vortex sheet strength, solves for N point vortex strengths to satisfy N constraints on the bound vortex sheet strength that regularize specified edges.\n\nFields\n\nibp::GridPotentialFlow.IBPoisson{TU,TF} where TF where TU\nibp: Immersed boundary poisson inner system with re-scaled regularization operator that solves for the streamfunction and bound vortex sheet strength, given a streamfunction boundary condition on immersed boundary points.\none_vec::Array{TF,1} where TF\none_vec: Array of vectors with the i-th entry of the j-th vector equal to one if i is an index of the points that belong to the j-th body and zero otherwise.\ne_vec::Array{TF,1} where TF\ne_vec: Array of unit vectors with the inner product of the i-th unit vector and vortex sheet strength equal to the value of the vortex sheet strength at the i-th edge.\nvidx_vec::Array{Array{Int64,1},1}\nvidx_vec: Array of vectors with the i-th vector containing the indices of the vortices that are shedded from the i-th body.\nf₀::Any\nf₀: Unregularized vortex sheet strength due to a uniform unit boundary condition for the streamfunction on all immersed bodies.\nf₀_vec::Array{TF,1} where TF\nf₀_vec: Array of unregularized bound vortex sheet strengths with the i-th entry the vortex sheet strength due to a uniform unit boundary condition for the streamfunction on the i-th immersed body and zero everywhere else.\nf̃₀_vec::Array{TF,1} where TF\nf̃₀_vec: Array of unregularized bound vortex sheet strengths, obtained using the re-scaled regularization operator, with the i-th entry the bound vortex sheet strength due to a uniform unit boundary condition for the streamfunction on the i-th immersed body and zero everywhere else.\nf̃_vec::Array{TF,1} where TF\nf̃vec: Array of unregularized bound vortex sheet strengths, obtained using the re-scaled regularization operator, with the i-th entry the bound vortex sheet strength due to the i-th vorticity field in `dvec` and a zero boundary condition for the streamfunction on all bodies.\nΓ₀::Float64\nΓ₀: The circulation of the of the bound vortex sheet strength f₀.\nd_vec::Array{TU,1} where TU\nd_vec: Array of vorticity fields with the i-th entry the vorticity field due to the i-th point vortex that is used for regularizing the edges with its strength set to one and the other point vortex strengths set to zero.\nactivef̃lim_vec::Array{Float64,1}\nactivef̃lim_vec: Array of f̃ values that are used as the right-hand side for the constraints on f̃ when solving the system. These values are chosen by comparing the unconstrained f̃ from the inner system to the limits provided in rhs to ldiv! and selecting the limit that is exceeded or setting it to Inf if no limit is exceeded.\nSout::Array{Float64,2}\nSout: Schur complement for the outer system.\n_TU_buf::Any\nBuffers\n_f_buf::Any\n_r₂_buf::Array{Float64,1}\n_y_buf::Array{Float64,1}\n\n\n\n\n\n","category":"type"},{"location":"private/#Base.length-Tuple{PotentialFlowBody}","page":"Private Documentation","title":"Base.length","text":"length(b::PotentialFlowBody) -> Any\n\n\nReturns the number of surface points in the body b.\n\n\n\n\n\n","category":"method"},{"location":"private/#GridPotentialFlow._computeδΓandψ₀!-Union{Tuple{TF}, Tuple{TU}, Tuple{Ne}, Tuple{Nb}, Tuple{GridPotentialFlow.ConstrainedIBPoissonSolution{TU,TF,T} where T,GridPotentialFlow.UnsteadyRegularizedIBPoisson{Nb,Ne,TU,TF},GridPotentialFlow.UnsteadyRegularizedIBPoissonRHS{TU,TF},Array{Int64,1}}} where TF where TU where Ne where Nb","page":"Private Documentation","title":"GridPotentialFlow._computeδΓandψ₀!","text":"_computeδΓandψ₀!(sol, sys, rhs, sheddingedges)\n\n\nComputes the vortex strengths for the edges sheddingedges and ψ₀ values and stores them in the δΓ_vec and ψ₀ fields of sol. If there are edges that are not in sheddingedges, their corresponding vortex strengths are set to zero.\n\n\n\n\n\n","category":"method"},{"location":"private/#GridPotentialFlow.getpositions-Tuple{StructArrays.StructArray{Vortex,N,C,I} where I where C<:Union{Tuple, NamedTuple} where N}","page":"Private Documentation","title":"GridPotentialFlow.getpositions","text":"getpositions(vl::StructArrays.StructArray{Vortex,N,C,I} where I where C<:Union{Tuple, NamedTuple} where N) -> VectorData\n\n\nReturns the positions of all point vortices in the StructArray vl as VectorData.\n\n\n\n\n\n","category":"method"},{"location":"private/#GridPotentialFlow.getregularizededges-Tuple{AbstractArray{PotentialFlowBody,1},Int64}","page":"Private Documentation","title":"GridPotentialFlow.getregularizededges","text":"getregularizededges(b::AbstractArray{PotentialFlowBody,1}, i::Int64) -> Any\n\n\nReturns the indices in the global set of surface point data of the regularized points of body i in b.\n\n\n\n\n\n","category":"method"},{"location":"private/#GridPotentialFlow.getregularizededges-Tuple{AbstractArray{PotentialFlowBody,1}}","page":"Private Documentation","title":"GridPotentialFlow.getregularizededges","text":"getregularizededges(b::AbstractArray{PotentialFlowBody,1}) -> Array{Int64,1}\n\n\nReturns the indices in the global set of surface point data of all regularized points in b.\n\n\n\n\n\n","category":"method"},{"location":"private/#GridPotentialFlow.getstrengths-Tuple{StructArrays.StructArray{Vortex,N,C,I} where I where C<:Union{Tuple, NamedTuple} where N}","page":"Private Documentation","title":"GridPotentialFlow.getstrengths","text":"getstrengths(vl::StructArrays.StructArray{Vortex,N,C,I} where I where C<:Union{Tuple, NamedTuple} where N) -> ScalarData\n\n\nReturns the strengths of all point vortices in the StructArray vl as ScalarData.\n\n\n\n\n\n","category":"method"},{"location":"private/#GridPotentialFlow.setpositions!-Tuple{StructArrays.StructArray{Vortex,N,C,I} where I where C<:Union{Tuple, NamedTuple} where N,Any,Any}","page":"Private Documentation","title":"GridPotentialFlow.setpositions!","text":"setpositions!(vl::StructArrays.StructArray{Vortex,N,C,I} where I where C<:Union{Tuple, NamedTuple} where N, xnew::Any, ynew::Any) -> Any\n\n\nSets the x and y fields of the point vortices in the StructArray vl to the entries of xnew and ynew, respectively.\n\n\n\n\n\n","category":"method"},{"location":"private/#GridPotentialFlow.setstrengths!","page":"Private Documentation","title":"GridPotentialFlow.setstrengths!","text":"setstrengths!(vl::StructArrays.StructArray{Vortex,N,C,I} where I where C<:Union{Tuple, NamedTuple} where N, Γnew::Any) -> Any\nsetstrengths!(vl::StructArrays.StructArray{Vortex,N,C,I} where I where C<:Union{Tuple, NamedTuple} where N, Γnew::Any, idx::Any) -> Any\n\n\nSets the Γ field of the point vortices in the StructArray vl to the entries of Γnew.\n\n\n\n\n\n","category":"function"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"EditURL = \"<unknown>/literate/3.-Non-uniqueness-and-discrete-circulation.jl\"","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/#.-Non-uniqueness-and-discrete-circulation","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"","category":"section"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"There is no unique solution to the two-dimensional potential flow problem in the presence of an impenetrable surface, since one can choose any value for the uniform value mathfraks_0 and still enforce the no-penetration condition. Equivalently, we can specify any circulation about the body and still enforce this condition. For later use, let us write this uniform surface streamfunction as mathfraks_0 = s_0 mathfrak1, where s_0 is a single scalar value and mathfrak1 is a vector of ones on all surface points. The discrete circulation Gamma_b about the body is given by the sum of the bound vortex sheet data and can be written compactly as","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"Gamma_b = mathfrak1^T mathfrakf","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"In GridPotentialFlow.jl, the user cannot specify s_0 directly. Instead, the package solves the system","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"beginbmatrix\nmathsfL  mathsfR  0\nmathsfE   0  mathfrak1\n0  mathfrak1^T  0\nendbmatrix beginpmatrix mathsfs  mathfrakf  s_0 endpmatrix =\nbeginpmatrix -mathsfw  mathfraks_b  Gamma_b endpmatrix","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"and the circulation can be specified using the Γ keyword for each body. If it is not specified, it is set to zero. The return value of solvesystem has a field ψ₀, whose entries represent the value for s_0 for each body, which are in this case the Lagrange multipliers to enforce the specified circulation.","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"We now illustrate how to specify the circulation by simulating the flow around two cylinders that have different circulations.","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"using GridPotentialFlow\nusing Plots","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"Δx = 0.01\nLx = 2.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx);\nnothing #hide","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"The two cylinders are positioned using the tools from RigidTransform from RigidBodyTools.jl and the circulation of the first one is set to a non-zero value.","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"R = Lx/8;\nb_left = PotentialFlowBody(Circle(R,Δx),Γ=1.0)\nT = RigidTransform((-Lx/4,0.0),0.0)\nT(b_left);\nb_right = PotentialFlowBody(Circle(R,Δx))\nT = RigidTransform((Lx/4,0.0),0.0)\nT(b_right);\nnothing #hide","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"A plot of the streamfunction then clearly shows the non-zero circulation about the left cylinder.","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"model = VortexModel(g,bodies=[b_left,b_right])\ns = streamfunction(model)\nplot(s,g)\nplot!(b_left,fillcolor=:black,fillrange=0,fillalpha=0.25,linecolor=:black,linewidth=2)\nplot!(b_right,fillcolor=:black,fillrange=0,fillalpha=0.25,linecolor=:black,linewidth=2)","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"When the previously introduced saddle point system","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"beginbmatrix\nmathsfL  mathsfR \nmathsfE   0\nendbmatrix beginpmatrix mathsfs  mathfrakf endpmatrix =\nbeginpmatrix -mathsfw  mathfraks_b - mathfraks_0 endpmatrix","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"is solved, the resulting circulation is","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"Gamma_b = mathfrak1^T mathsfS^-1left(mathfraks_b^prime+mathsfEL^-1 mathsfwright)-s_0 mathfrak1^T mathsfS^-1 mathfrak1","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"where mathsfS = -mathsfEL^-1mathsfR is the Schur complement. The scalar factor mathfrak1^T mathsfS^-1 mathfrak1 in this expression is a property of the set of points and their immersion into the Cartesian grid. Part of this factor, mathsfS^-1 mathfrak1, represents the bound vortex sheet strength associated with a uniform, unit-strength streamfunction on the surface. This sheet has a particularly important role in some of the discussion to follow, so we will denote its strength by mathfrakf_0:","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"mathfrakf_0 equiv mathsfS^-1 mathfrak1","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"We demonstrate below the distribution of mathfrakf_0 for elliptical cylinders with different aspect ratios.","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"Δx = 0.004\nLx = 2.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx);\nnothing #hide","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"Let us consider four cylinders with aspect ratios 1, 2, 3, and infinity. An ellipse with infinite aspect ratio is a flat plate, so we construct that case separately.","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"a = Lx/4 # semi-major axis\nAR_list = [1.0,2.0,3.0]\nellipses = [Ellipse(a,a/AR,Δx) for AR in AR_list]\nbodies = PotentialFlowBody[]\npush!(bodies,[PotentialFlowBody(SplinedBody(hcat(e.x,e.y),3*cellsize(g))) for e in ellipses]...)\npush!(bodies,PotentialFlowBody(Plate(2*a,3*Δx)));\ncolors = [:blue,:red,:green,:black]\nplot()\nfor i in 1:length(bodies)\n    plot!(bodies[i],fillrange=0,fillalpha=0.0,linecolor=colors[i],linewidth=2)\nend\nplot!(xlim=xlim,ylim=ylim,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"To compute mathfrakf_0, we have to access the internal fields of the associated system of our vortexmodel.","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"f₀_list = []\nfor i in 1:length(bodies)\n    Δs = dlength(bodies[i]);\n    model = VortexModel(g,bodies=[bodies[i]]);\n    ones = ScalarData(length(bodies[i]))\n    ones .= 1.0\n    f₀ = model.system.ibp.Sfact\\ones\n    push!(f₀_list,f₀)\nend","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"Because the flat plate is an open body, we need to mirror and append its contents to itself to compare it to the ellipses. Furthermore, its bound vortex sheet strength should be divided by two because it represents gamma = gamma^+ + gamma^-","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"append!(f₀_list[end],reverse!(f₀_list[end]));\nΔs_plate = dlengthmid(bodies[end]);\nappend!(Δs_plate,reverse!(Δs_plate));\nplot(ylim=(-2,0),xlabel=\"p/N\",title=\"f₀ for ellipses of different aspect ratios\")\nfor i in 1:length(bodies)-1\n    plot!((1:length(f₀_list[i]))/length(f₀_list[i]),f₀_list[i]./dlength(bodies[i]),linecolor=colors[i],label=\"AR=$(AR_list[i])\")\nend\nplot!((1:length(f₀_list[end]))/length(f₀_list[end]),0.5*f₀_list[end]./Δs_plate,linecolor=colors[end],label=\"AR=inf\")","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"public/#Public-Documentation","page":"Public Documentation","title":"Public Documentation","text":"","category":"section"},{"location":"public/","page":"Public Documentation","title":"Public Documentation","text":"Documentation for GridPotentialFlow.jl's public interface.","category":"page"},{"location":"public/","page":"Public Documentation","title":"Public Documentation","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"public/#Contents","page":"Public Documentation","title":"Contents","text":"","category":"section"},{"location":"public/","page":"Public Documentation","title":"Public Documentation","text":"Pages = [\"public.md\"]","category":"page"},{"location":"public/#Index","page":"Public Documentation","title":"Index","text":"","category":"section"},{"location":"public/","page":"Public Documentation","title":"Public Documentation","text":"Pages = [\"public.md\"]","category":"page"},{"location":"public/#Public-Interface","page":"Public Documentation","title":"Public Interface","text":"","category":"section"},{"location":"public/","page":"Public Documentation","title":"Public Documentation","text":"Modules = [GridPotentialFlow]\nPrivate = false","category":"page"},{"location":"public/#GridPotentialFlow.PotentialFlowBody","page":"Public Documentation","title":"GridPotentialFlow.PotentialFlowBody","text":"mutable struct PotentialFlowBody\n\nDefines a rigid body for VortexModel in GridPotentialFlow.jl.\n\n\n\n\n\n","category":"type"},{"location":"public/#GridPotentialFlow.PotentialFlowBody-Union{Tuple{Body{N,C}}, Tuple{C}, Tuple{N}} where C where N","page":"Public Documentation","title":"GridPotentialFlow.PotentialFlowBody","text":"Constructs a potential flow body with shape b, linear velocity U, rotational velocity Ω, and initial circulation Γ. Edges that should be regularized can be specified in edges and their suction parameter ranges in σ, which defaults to zero for each regularized edge.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.Vortex","page":"Public Documentation","title":"GridPotentialFlow.Vortex","text":"mutable struct Vortex\n\nDefines a point vortex with x-position x, y-position y, and strength Γ.\n\nFields\n\nx::Float64\nx: x-coordinate of the vortex position.\ny::Float64\ny: y-coordinate of the vortex position.\nΓ::Float64\nΓ: Strength of the vortex. Positive if counter-clockwise.\n\n\n\n\n\n","category":"type"},{"location":"public/#GridPotentialFlow.VortexModel","page":"Public Documentation","title":"GridPotentialFlow.VortexModel","text":"mutable struct VortexModel{Nb, Ne, TS<:Union{CartesianGrids.Laplacian, GridPotentialFlow.AbstractPotentialFlowSystem}, TU<:Nodes, TE<:Edges, TF<:ScalarData, TX<:VectorData}\n\nDefines a grid-based vortex model with Nb bodies and Ne edges that are regularized. If isshedding is true, the strengths of the last Ne vortices in vortices can be computed in order to regularized the Ne edges.\n\nFields\n\ng::PhysicalGrid\ng: The grid on which the vortex model is defined.\nbodies::Array{PotentialFlowBody,1}\nbodies: Bodies in the vortex model.\nvortices::StructArrays.StructArray{Vortex,1,C,I} where I where C<:Union{Tuple, NamedTuple}\nvortices: Point vortices in the vortex model.\nU∞::Tuple{Float64,Float64}\nU∞: Uniform flow in the vortex model.\nsystem::Union{CartesianGrids.Laplacian, GridPotentialFlow.AbstractPotentialFlowSystem}\nsystem: Potential flow system that has to be solved with an AbstractPotentialFlowRHS and an AbstractPotentialFlowSolution to compute the potential flow that governs the vortex model.\n\n_nodedata::Nodes\nInternal fields\n_edgedata::Edges\n_bodyvectordata::VectorData\n_ψ::Nodes\n_f::ScalarData\n_w::Nodes\n_ψb::ScalarData\n\nExamples\n\n(under construction)\n\n\n\n\n\n","category":"type"},{"location":"public/#GridPotentialFlow.VortexModel-Tuple{PhysicalGrid,Array{PotentialFlowBody,1},StructArrays.StructArray{Vortex,1,C,I} where I where C<:Union{Tuple, NamedTuple},Tuple{Float64,Float64}}","page":"Public Documentation","title":"GridPotentialFlow.VortexModel","text":"VortexModel(g::PhysicalGrid, bodies::Array{PotentialFlowBody,1}, vortices::StructArrays.StructArray{Vortex,1,C,I} where I where C<:Union{Tuple, NamedTuple}, U∞::Tuple{Float64,Float64}) -> VortexModel\n\n\nConstructs a vortex model using the given function.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.addedmass-Union{Tuple{VortexModel{Nb,Ne,TS,TU,TE,TF,TX} where TX<:VectorData where TF<:ScalarData where TE<:Edges where TU<:Nodes where TS<:Union{CartesianGrids.Laplacian, GridPotentialFlow.AbstractPotentialFlowSystem}}, Tuple{Ne}, Tuple{Nb}} where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.addedmass","text":"Computes the translational coefficients of the added mass matrix of the bodies in the vortex model vm.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.getU-Tuple{PotentialFlowBody}","page":"Public Documentation","title":"GridPotentialFlow.getU","text":"getU(b::PotentialFlowBody) -> Tuple{Float64,Float64}\n\n\nReturns the linear velocity of the body b.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.getrange-Tuple{AbstractArray{PotentialFlowBody,1},Int64}","page":"Public Documentation","title":"GridPotentialFlow.getrange","text":"getrange(b::AbstractArray{PotentialFlowBody,1}, i::Int64) -> Any\n\n\nReturns the subrange of indices in the global set of surface point data corresponding to body i in b.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.getvortexpositions-Union{Tuple{VortexModel{Nb,Ne,TS,TU,TE,TF,TX} where TX<:VectorData where TF<:ScalarData where TE<:Edges where TU<:Nodes where TS<:Union{CartesianGrids.Laplacian, GridPotentialFlow.AbstractPotentialFlowSystem}}, Tuple{Ne}, Tuple{Nb}} where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.getvortexpositions","text":"Returns the positions of the vortices in the vortex model vm.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.getΓ-Tuple{PotentialFlowBody}","page":"Public Documentation","title":"GridPotentialFlow.getΓ","text":"getΓ(b::PotentialFlowBody) -> Float64\n\n\nReturns the bound circulation of the body b.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.getΩ-Tuple{PotentialFlowBody}","page":"Public Documentation","title":"GridPotentialFlow.getΩ","text":"getΩ(b::PotentialFlowBody) -> Float64\n\n\nReturns the rotational velocity of the body b.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.impulse-Tuple{VortexModel}","page":"Public Documentation","title":"GridPotentialFlow.impulse","text":"impulse(vm)\n\n\nComputes the impulse associated with the current state vortices and bodies in the vortex model vm. Note that newly inserted vortices should have their strengths set prior to calling this function to be included in the impulse calculation.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.impulse-Union{Tuple{Ne}, Tuple{Nb}, Tuple{VortexModel{Nb,Ne,TS,TU,TE,TF,TX} where TX<:VectorData where TF<:ScalarData where TE<:Edges where TU<:Nodes where TS<:Union{CartesianGrids.Laplacian, GridPotentialFlow.AbstractPotentialFlowSystem},Nodes{Dual,NX,NY,T,DT} where DT<:(AbstractArray{T,2} where T) where T<:Number where NY where NX,ScalarData}} where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.impulse","text":"impulse(vm, wphysical, fphysical)\n\n\nComputes the impulse associated with the vorticity wphysical, the bound vortex sheet strength fphysical, and the velocities of the discrete points of the bodies in vm.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.impulse-Union{Tuple{TS}, Tuple{TS,VortexModel}} where TS<:GridPotentialFlow.AbstractIBPoissonSolution","page":"Public Documentation","title":"GridPotentialFlow.impulse","text":"impulse(sol, vm)\n\n\nComputes the impulse associated with the body motions in the vortex model vm and the vortex sheet strength in sol. Note that newly inserted vortices should have their strengths set prior to calling this function to be included in the impulse calculation.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.pushvortices!-Union{Tuple{Ne}, Tuple{Nb}, Tuple{VortexModel{Nb,Ne,TS,TU,TE,TF,TX} where TX<:VectorData where TF<:ScalarData where TE<:Edges where TU<:Nodes where TS<:Union{CartesianGrids.Laplacian, GridPotentialFlow.AbstractPotentialFlowSystem},Vararg{Any,N} where N}} where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.pushvortices!","text":"pushvortices!(vm, newvortices)\n\n\nAdds newvortices to the existing vortices in the vortex model vm.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.setU-Tuple{PotentialFlowBody,Tuple{Float64,Float64}}","page":"Public Documentation","title":"GridPotentialFlow.setU","text":"setU(b::PotentialFlowBody, U::Tuple{Float64,Float64}) -> Tuple{Float64,Float64}\n\n\nSets the linear velocity of the body b to U.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.setU∞-Tuple{VortexModel,Any}","page":"Public Documentation","title":"GridPotentialFlow.setU∞","text":"setU∞(vm, U∞)\n\n\nSets the uniform flow of the vortex model vm to U∞.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.setvortexpositions!-Union{Tuple{Nv}, Tuple{Ne}, Tuple{Nb}, Tuple{VortexModel{Nb,Ne,TS,TU,TE,TF,TX} where TX<:VectorData where TF<:ScalarData where TE<:Edges where TU<:Nodes where TS<:Union{CartesianGrids.Laplacian, GridPotentialFlow.AbstractPotentialFlowSystem},VectorData{Nv,T,DT} where DT<:(AbstractArray{T,1} where T) where T}} where Nv where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.setvortexpositions!","text":"setvortexpositions!(vm, X)\n\n\nSets the positions of the vortices in the vortex model vm to the provided X.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.setvortexstrengths!-Union{Tuple{TΓ}, Tuple{Ne}, Tuple{Nb}, Tuple{VortexModel{Nb,Ne,TS,TU,TE,TF,TX} where TX<:VectorData where TF<:ScalarData where TE<:Edges where TU<:Nodes where TS<:Union{CartesianGrids.Laplacian, GridPotentialFlow.AbstractPotentialFlowSystem},TΓ}, Tuple{VortexModel{Nb,Ne,TS,TU,TE,TF,TX} where TX<:VectorData where TF<:ScalarData where TE<:Edges where TU<:Nodes where TS<:Union{CartesianGrids.Laplacian, GridPotentialFlow.AbstractPotentialFlowSystem},TΓ,Any}} where TΓ<:(AbstractArray{T,1} where T) where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.setvortexstrengths!","text":"setvortexstrengths!(vm, Γ)\nsetvortexstrengths!(vm, Γ, idx)\n\n\nSets the strenghts of the vortices in the vortex model vm to the provided Γ. Indices can be provided in idx to specify the indices of the vortices whose strengths have to be set, in which case the length of Γ must be the same as the number of indices.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.setvortices!-Union{Tuple{Ne}, Tuple{Nb}, Tuple{VortexModel{Nb,Ne,TS,TU,TE,TF,TX} where TX<:VectorData where TF<:ScalarData where TE<:Edges where TU<:Nodes where TS<:Union{CartesianGrids.Laplacian, GridPotentialFlow.AbstractPotentialFlowSystem},Array{Vortex,1}}} where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.setvortices!","text":"setvortices!(vm, newvortices)\n\n\nReplaces the vortices of the vortex model vm by a copy of newvortices.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.setΓ-Tuple{PotentialFlowBody,Float64}","page":"Public Documentation","title":"GridPotentialFlow.setΓ","text":"setΓ(b::PotentialFlowBody, Γ::Float64) -> Float64\n\n\nSets the bound circulation of the body b to Γ.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.setΩ-Tuple{PotentialFlowBody,Float64}","page":"Public Documentation","title":"GridPotentialFlow.setΩ","text":"setΩ(b::PotentialFlowBody, Ω::Float64) -> Float64\n\n\nSets the rotational velocity of the body b to Ω.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.solve!-Union{Tuple{TS}, Tuple{TU}, Tuple{Nb}, Tuple{GridPotentialFlow.PoissonSolution,VortexModel{0,0,TS,TU,TE,TF,TX} where TX<:VectorData where TF<:ScalarData where TE<:Edges}} where TS<:CartesianGrids.Laplacian where TU where Nb","page":"Public Documentation","title":"GridPotentialFlow.solve!","text":"solve!(sol, vm)\n\n\nSolves the saddle point system associated with the vortex model vm and stores the solution in sol. If the vortex model contains bodies with regularized edges and a number of vortices which is greater than or equal to the number of regularized edges, the returned solution contains the computed strengths of the last N vortices in vm, with N the number of regularized edges.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.solve-Union{Tuple{VortexModel{0,0,TS,TU,TE,TF,TX} where TX<:VectorData where TF<:ScalarData where TE<:Edges}, Tuple{TU}, Tuple{TS}, Tuple{Ne}, Tuple{Nb}} where TU where TS<:CartesianGrids.Laplacian where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.solve","text":"Solves the saddle point system associated with the vortex model vm and returns the solution. If the vortex model contains bodies with regularized edges and a number of vortices which is greater than or equal to the number of regularized edges, the returned solution contains the computed strengths of the last N vortices in vm, with N the number of regularized edges.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.streamfunction!-Union{Tuple{TU}, Tuple{TS}, Tuple{Ne}, Tuple{Nb}, Tuple{TU,VortexModel{0,0,TS,TU,TE,TF,TX} where TX<:VectorData where TF<:ScalarData where TE<:Edges}} where TU where TS<:CartesianGrids.Laplacian where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.streamfunction!","text":"streamfunction!(ψ, vm)\n\n\nComputes the stream function field ψ on the physical grid for the potential flow associated with the current state of the vortex model vm.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.streamfunction-Union{Tuple{VortexModel{Nb,Ne,TS,TU,TE,TF,TX} where TX<:VectorData}, Tuple{TF}, Tuple{TE}, Tuple{TU}, Tuple{TS}, Tuple{Ne}, Tuple{Nb}} where TF where TE where TU where TS where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.streamfunction","text":"Computes and returns the stream function field on the physical grid for the potential flow associated with the current state of the vortex model vm.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.subtractcirculation!-Tuple{AbstractArray{PotentialFlowBody,1},AbstractArray{T,1} where T}","page":"Public Documentation","title":"GridPotentialFlow.subtractcirculation!","text":"subtractcirculation!(b::AbstractArray{PotentialFlowBody,1}, δΓ_vec::AbstractArray{T,1} where T)\n\n\nReturns the indices in the global set of surface point data of all regularized points in b.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.vortexvelocities!-Union{Tuple{TU}, Tuple{TS}, Tuple{Ne}, Tuple{Nb}, Tuple{VectorData,VortexModel{Nb,Ne,TS,TU,TE,TF,TX} where TX<:VectorData where TF<:ScalarData where TE<:Edges,TU}} where TU where TS where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.vortexvelocities!","text":"vortexvelocities!(Ẋ_vortices, vm, ψ)\n\n\nComputes and stores in Ẋ_vortices the flow velocity, associated with the discrete vector potential field ψ, as VectorData at the locations of the vortices stored in the vortex model vm.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.vortexvelocities!-Union{Tuple{VortexModel{Nb,Ne,TS,TU,TE,TF,TX} where TX<:VectorData where TF<:ScalarData where TE<:Edges where TU<:Nodes where TS<:Union{CartesianGrids.Laplacian, GridPotentialFlow.AbstractPotentialFlowSystem}}, Tuple{Ne}, Tuple{Nb}} where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.vortexvelocities!","text":"Returns the flow velocity as VectorData at the locations of the vortices stored in the vortex model vm, accounting for bodies in vm. If the vm has Ne regularized edges and vortices, the strengths of the last Ne vortices will be computed and set in vm and the circulation of the shedded vortices will be subtracted from the bound circulation of each body.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.vorticity!-Union{Tuple{TF}, Tuple{TE}, Tuple{TU}, Tuple{TS}, Tuple{Ne}, Tuple{Nb}, Tuple{TU,VortexModel{Nb,Ne,TS,TU,TE,TF,TX} where TX<:VectorData}} where TF where TE where TU where TS where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.vorticity!","text":"vorticity!(wphysical, vm; onlybulk)\n\n\nComputes the vorticity field w associated with the vortices stored in the vortex model vm on the physical grid. If the extra boolean keyword onlybulk is set to true, the function ignores the vorticity from the last Ne vortices in vm.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.vorticity-Union{Tuple{VortexModel{Nb,Ne,TS,TU,TE,TF,TX} where TX<:VectorData}, Tuple{TF}, Tuple{TE}, Tuple{TU}, Tuple{TS}, Tuple{Ne}, Tuple{Nb}} where TF where TE where TU where TS where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.vorticity","text":"Computes the vorticity field associated with the vortices stored in the vortex model vm on the physical grid.\n\n\n\n\n\n","category":"method"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"EditURL = \"<unknown>/literate/5.-Generalized-edge-conditions.jl\"","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/#.-Generalized-edge-conditions","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"","category":"section"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"In the previous part, we demonstrated the means of annihilating the (nearly) singular behavior at edges on a discretized surface. In some cases, our desire is not to annihilate this behavior, but simply to keep it within some bounds. In the analytical treatment of potential flow problems, this objective is served by placing an inequality constraint on the edge suction parameter. That parameter is proportional to the coefficient on the bound vortex sheet strength's singularity, so in this discrete setting, in which we have extracted the singular part of mathfrakf in the form of mathfrakf_0, we expect the suction parameter to be related to the value of tildemathfrakf at the edge. In fact, by simple comparison, it can be shown that","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"mathfrake_k^Ttildemathfrakf = -frac2pi cGamma_0 sigma_k","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"for a flat plate of length c, where sigma_k is the suction parameter at the edge corresponding to point k.","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"Let sigma_k^mathrmmin and sigma_k^mathrmmax denote the minimum and maximum tolerable values of sigma_k at edge k. We then seek to confine the suction parameter to the range sigma_k^mathrmmin leq sigma_k leq sigma_k^mathrmmax. This generalized edge constraint is placed on the suction parameter of the intermediate sheet tildemathfrakf^*. To avoid confusion, we will redefine the bounds based on this smooth part of the vortex sheet rather than sigma_k itself; for this, we define f^mathrmmin_k = -frac2pi cGamma_0 sigma_k^mathrmmax and f^mathrmmax_k = -frac2pi cGamma_0 sigma_k^mathrmmin if Gamma_0 is positive or f^mathrmmax_k = -frac2pi cGamma_0 sigma_k^mathrmmax and f^mathrmmin_k = -frac2pi cGamma_0 sigma_k^mathrmmin if Gamma_0 is negative. Thus, we inspect whether the value mathfrake_k^Ttildemathfrakf^* lies in the range","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"f^mathrmmin_k leq mathfrake_k^Ttildemathfrakf^* leq f^mathrmmax_k","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"If mathfrake_k^Ttildemathfrakf^* lies within this range, then no new vortex is created near the edge (or equivalently, a new vortex of zero strength is created); if mathfrake_k^Ttildemathfrakf^*  f^mathrmmax_k, then we create a new vortex so that mathfrake_k^Ttildemathfrakf = f^mathrmmax_k; and if mathfrake_k^Ttildemathfrakf^*  f^mathrmmin_k, then we do the same, but now so that mathfrake_k^Ttildemathfrakf = f^mathrmmin_k. Note that the Kutta condition simply corresponds to setting f^mathrmmin_k = f^mathrmmax_k = 0.","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"Let's illustrate this again with the example of a flat plate. To clearly show the effect of varying the suction parameter, we will run a simulation of the vortex shedding for a couple of time steps for three different suction parameter ranges. First we create the grid and the flate plate.","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"using GridPotentialFlow\nusing Plots","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"Δx = 0.01\nLx = 2.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx);\nc = Lx/2 # chord length\nα = -π/3 # angle of attack\nplate = Plate(c,4*cellsize(g));\nTr = RigidTransform((0.0,0.0),α)\nTr(plate)\nΔs = dlengthmid(plate);\nnothing #hide","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"We create three instances of PotentialFlowBody, each one with a different suction parameter range. We only vary the suction parameter at the leading edge and keep it at zero (Kutta condition) at the trailing edge.","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"σLE_list = [0.0,0.05,0.1];\npfb_list = [PotentialFlowBody(plate,edges=[1,length(plate)],σ=[SuctionParameter(σLE),SuctionParameter(0.0)]) for σLE in σLE_list];\nnothing #hide","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"The initial point vortices are the same in each case.","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"Δt = 2e-2\nvLE = Vortex(plate.x[1]+3Δt*plate.len*cos(plate.α+π/2),plate.y[1]+3Δt*plate.len*sin(plate.α+π/2),0.0);\nvTE = Vortex(plate.x[end]+3Δt*cos(α+π/2),plate.y[end]+3Δt*sin(α+π/2),0.0);\nnothing #hide","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"At each time step, we will need to insert new point vortices near the regularized edges to simulate the vortex shedding. A good strategy is to place them one-third of the way from the edge to the last released vortex from that edge. This will happen at each time step, so we create a function for it.","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"function createsheddedvortices(plate,oldvortices)\n\n    vLE = Vortex(2/3*plate.x[1]+1/3*oldvortices[end-1].x,2/3*plate.y[1]+1/3*oldvortices[end-1].y,0.0)\n    vTE = Vortex(2/3*plate.x[end]+1/3*oldvortices[end].x,2/3*plate.y[end]+1/3*oldvortices[end].y,0.0)\n\n    return vLE, vTE\nend","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"We create a vortex models with the initial point vortices.","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"model_list = [VortexModel(g,bodies=[pfb],vortices=[vLE,vTE],U∞=(1.0,0.0)) for pfb in pfb_list];\nnothing #hide","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"Now we can advance the solution in time.","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"T = 0:Δt:0.2\nfor t in T\n    for vm in model_list\n        X = getvortexpositions(vm)\n        Ẋ = vortexvelocities!(vm)\n        X .= X .+ Ẋ*Δt\n        setvortexpositions!(vm, X)\n        vLEnew, vTEnew = createsheddedvortices(plate,vm.vortices[end-1:end])\n        pushvortices!(vm,vLEnew,vTEnew)\n    end\nend","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"By plotting the positions of the point vortices emanating from the leading edge, we see that as sigma_k^mathrmmax increases, the stream of point vortices is swept back from the edge.","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"colors = [:red,:blue,:green];\nplot(plate,fillcolor=:black,fillrange=0,fillalpha=0.25,linecolor=:black,linewidth=2,xlabel=\"x\",ylabel=\"y\")\nfor i in 1:length(model_list)\n    plot!(model_list[i].vortices.x[4:2:end],model_list[i].vortices.y[4:2:end],color=colors[i],marker=:circle,markersize=2)\n    plot!(model_list[i].vortices.x[3:2:end],model_list[i].vortices.y[3:2:end],color=colors[i],marker=:circle,markersize=2)\n    scatter!(model_list[i].vortices.x[1:2],model_list[i].vortices.y[1:2],color=colors[i],marker=:circle,markersize=2,label=\"σLE=$(σLE_list[i])\")\nend\nplot!()","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"plot(xlabel=\"body point index\",ylabel=\"f̃\")\nfor i in 1:length(model_list)\n    sol = solve(model_list[i]);\n    plot!(sol.f./model_list[i].system.f₀,linecolor=colors[i],label=\"σLE=$(σLE_list[i])\")\nend\nplot!()","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"EditURL = \"<unknown>/literate/2.-Potential-flow-with-an-impenetrable-surface.jl\"","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/#.-Potential-flow-with-an-impenetrable-surface","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"","category":"section"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"This part introduces the treatment of rigid impenetrable surfaces in GridPotentialFlow. We can impose the no-penetration constraint by setting the fluid streamfunction equal to that of the surface mathfraks_b, up to a uniform value s_0. The discrete no-penetration constraint is thus","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"mathsfEs=mathfraks_b-mathsfE mathsfs_infty-mathfraks_0","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"where mathsfE is the interpolation operator that interpolates grid data to the surface points, mathsfs_infty is the streamfunction of the uniform flow. For a body translating at velocity (UV) and rotating at angular velocity Omega, this streamfunction would be","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"mathfraks_bk = U mathfrakr_y - V mathfrakr_x - frac12 Omega (mathfrakr_x^2+mathfrakr_y^2)","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"For later shorthand, we will denote the difference between the body motion streamfunction and interpolated uniform flow streamfunction by mathfraks_b equiv mathfraks_b - mathsfE mathsfs_infty. The no-penetration constraint is enforced in the basic potential flow problem with the help of a vector of Lagrange multipliers, mathfrakf, on the surface points. The modified potential flow problem is thus","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"mathsfLs + mathsfRmathfrakf = -mathsfw","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"where mathsfR is the regularization operator that transfers data from surface data to nodes. mathsfE can be constructed (and we will assume it has) so that it is the transpose of the interpolation operator, mathsfE = mathsfR^T.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"From the previous equation, it is clear (by simple comparison with the vorticity on the right-hand side) that the vector mathfrakf represents the strength of the discrete bound vortex sheet on the surface. Suppose we consider the bound vortex sheet gamma(s) that emerges from the analogous continuous problem on the undiscretized surface, where s is the arc-length parameter along the surface. At each point p, the discrete solution mathfrakf is approximately equal to this continuous solution, multiplied by the length delta S_p of the small segment surrounding the point:","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"mathfrake_p^T mathfrakf approx gamma(s) delta S_p","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"Thus, the potential flow problem in the presence of the impenetrable surface is","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"beginbmatrix\nmathsfL  mathsfR \nmathsfE   0\nendbmatrix beginpmatrix mathsfs  mathfrakf endpmatrix =\nbeginpmatrix -mathsfw  mathfraks_b - mathfraks_0 endpmatrix","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"This problem has the structure of a generic saddle-point problem. GridPotentialFlow.jl automatically formulates the no-penetration constraint on the streamfunction and solves the saddle system when it needs to. See the next page for the role of mathfraks_0 and how it will be treated internally.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"We will now consider two examples. In these examples, we use the following grid.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"using GridPotentialFlow\nusing Plots","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"Δx = 0.02\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx);\nnothing #hide","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/#Vortex-near-a-cylinder","page":"2. Potential flow with an impenetrable surface","title":"Vortex near a cylinder","text":"","category":"section"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"As an basic example, consider now a point vortex near a circular cylinder.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"A body in GridPotentialFlow.jl is represented by PotentialFlowBody. This is a wrapper around a Body from RigidBodyTools.jl and can be endowed with a linear velocity, rotational velocity, circulation, and other properties using the appropriate keywords during construction or by mutating its fields using its setter methods. For our circular cylinder, we use the Circle shape.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"Rc = Lx/4\nΔs = 2Δx\nbody = PotentialFlowBody(Circle(Rc,Δs))","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"We choose an initial position R_v of the vortex at 32 R_c from the origin.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"Rv = 3/2*Rc\nΓv = 1.0\nv = Vortex(Rv,0.0,Γv);\nnothing #hide","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"And we set an equal and opposite circulation about the body","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"setΓ(body,-Γv)","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"We construct the VortexModel by using the optional bodies keyword. In this case, we are interested in the bound vortex sheet strength mathfrakf, instead of just the streamfunction field. For this reason, we use solve, which in this case returns a ConstrainedIBPoissonSolution.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"model = VortexModel(g,vortices=[v],bodies=[body]);\nsol = solve(model);\nnothing #hide","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"# Analytical solution (vortex at Rv and image vortex at Rc^2/Rv)\nr1 = sqrt.((body.points.x.-Rv).^2 .+ (body.points.y).^2) # distance from vortex to points on circle\nr2 = sqrt.((body.points.x.-Rc^2/Rv).^2 .+ (body.points.y).^2) # distance from image vortex to points on circle\nθ1 = π.+atan.((body.points.y)./(body.points.x.-Rv)) # angle from vortex to points on circle\nθ2 = atan.((body.points.y),(body.points.x.-Rc^2/Rv)) # angle from image vortex to points on circle\nv1x = -v.Γ./(2π*r1).*cos.(θ1.-π/2) # x velocity on circle induced by vortex\nv1y = -v.Γ./(2π*r1).*sin.(θ1.-π/2) # y velocity on circle induced by vortex\nv2x = v.Γ./(2π*r2).*cos.(θ2.-π/2) # x velocity on circle induced by image vortex\nv2y = v.Γ./(2π*r2).*sin.(θ2.-π/2) # y velocity on circle induced by image vortex\nV = sqrt.((v1x.+v2x).^2+(v1y.+v2y).^2) # velocity magnitude on circle\nγ = -V; # bound vortex sheet strength on circle (velocity on circle is clockwise if positive vortex is to the right of it)","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"We can then easily retrieve the streamfunction and the bound vortex sheet strength from the fields of the solution variable.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"plot(sol.ψ,g)\nplot!(body,fillcolor=:black,fillrange=0,fillalpha=0.25,linecolor=:black,linewidth=2)\nscatter!([v.x],[v.y],color=:black,markersize=2,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"For this example, we can easily calculate the analytical bound vortex sheet strength gamma and compare it with our numerical solution f. See the notebook in the examples folder for the analytical solution.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"plot(sol.f./Δs,label=\"f/ds\",xlabel=\"body point index\")\nplot!(γ,label=\"gamma\")","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/#Moving-cylinder","page":"2. Potential flow with an impenetrable surface","title":"Moving cylinder","text":"","category":"section"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"In this example we will create a model with a moving body.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"Here we use the keyword U to add create a body with a linear velocity.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"body = PotentialFlowBody(Circle(Rc,Δs), U=(1.0,0.0))\nmodel = VortexModel(g,bodies=[body]);\nsol = solve(model);\nnothing #hide","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"# Analytical solution\nθ = atan.(body.points.y,body.points.x)\nγ = 2*sin.(θ);","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"plot(sol.ψ,g)\nplot!(body,fillcolor=:black,fillrange=0,fillalpha=0.25,linecolor=:black,linewidth=2,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"Again, we can compare the discrete bound vortex sheet strength with the analytical vortex sheet strength.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"plot(sol.f./Δs,label=\"f/ds\",xlabel=\"body point index\")\nplot!(γ,label=\"gamma\")","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"EditURL = \"<unknown>/literate/4.-The-Kutta-condition.jl\"","category":"page"},{"location":"manual/4.-The-Kutta-condition/#.-The-Kutta-condition","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"","category":"section"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"For surfaces that contain convex edges, the vortex sheet strength assumes a singular behavior in the vicinity of these edges, with a strength that depends on the interior angle of the edge: sharper edges have more singular behavior. In the discrete representation of the surface, edges are only approximately represented by the sudden disruptions of positions in clusters of adjacent points. The behavior in this discrete form is not quite singular, but the solution for the vortex sheet strength mathfrakf nonetheless exhibits a large and rapid change of amplitude.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Let's illustrate this with the example of a flat plate. First create the grid.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"using GridPotentialFlow\nusing Plots","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Δx = 0.01\nLx = 2.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx);\nnothing #hide","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"To create a potential flow model with flat plate, we use the Plate constructor from RigidBodyTools.jl and transform the body such that its angle of attack is α.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"c = Lx/2 # chord length\nα = -π/6 # angle of attack\nplate = Plate(c,4*cellsize(g))\nTr = RigidTransform((0.0,0.0),α)\nTr(plate)\npfb = PotentialFlowBody(plate);\nmodel = VortexModel(g,bodies=[pfb]);\nnothing #hide","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"To simulate the plate in a uniform flow, we have to set the U∞ field of the vortex model to our desired value.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"setU∞(model,(1.0,0.0))\nsol = solve(model);\nnothing #hide","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"By plotting a large number streamlines, we see how the flow accelerates as it tries to make its way around the sharp edges of the flat plate. In the continuous case, the velocity field would be singular at the edges.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"plot(sol.ψ,g,levels=60);\nplot!(plate,linecolor=:black,linewidth=2,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"The continous vortex sheet strength shows similar singularities at the edges, and also in our discrete case, vortex sheet strength the indeed assumes an approximate singular behavior near those edges.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"plot(sol.f,xlabel=\"body point index\",ylabel=\"f\",legend=false)","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"If we seek to eliminate this behavior, we must first have some means of exposing it. In fact, for any discretized surface, the essence of this nearly-singular behavior lies in the previously defined vector mathfrakf_0, and all other bound vortex sheets associated with the same surface share the same nearly-singular behavior. Thus, we will use a multiplicative decomposition of the vortex sheet strength:","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"mathfrakf = mathfrakf_0 circ tildemathfrakf","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"where circ is the Hadamard product. This decomposed form isolates the singular behavior into mathfrakf_0, and tildemathfrakf is a relatively smoother vector of surface point data.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"For our flat plate, we create mathfrakf_0 in the same way as we did on the previous page.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"ones = ScalarData(length(plate))\nones .= 1.0\nf₀ = model.system.ibp.Sfact\\ones\nplot(f₀)","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Then we can plot the smooth tildemathfrakf as follows.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"plot(sol.f./f₀,xlabel=\"body point index\",ylabel=\"f̃\",legend=false)","category":"page"},{"location":"manual/4.-The-Kutta-condition/#Using-the-Kutta-condition-in-a-steady-state-problem","page":"4. The Kutta condition","title":"Using the Kutta condition in a steady-state problem","text":"","category":"section"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"The Kutta condition corresponds to annihilating the nearly-singular behavior at a surface point. At such points, we will set the corresponding value of tildemathfrakf to zero. Suppose we wish to enforce the Kutta condition at an edge corresponding to surface point k. The condition is","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"mathfrake_k^T tildemathfrakf = 0","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"In the regularization operation on mathfrakf, we can absorb mathfrakf_0 into mathsfR, first noting that the Hadamard product can alternatively be written with the help of a diagonal matrix,","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"mathfrakf = mathfrakf_0 circ tildemathfrakf = mathsfDmathfrakf_0 tildemathfrakf","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Then, we can define a re-scaled regularization operator,","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"mathsfRmathfrakf = mathsfR mathsfDmathfrakf_0 tildemathfrakf = tildemathsfR tildemathfrakf","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"We will first take the steady-state approach to enforce the Kutta condition: allow the bound circulation to be set appropriately, with the implicit understanding that there is a starting vortex of equal and opposite circulation at infinity that preserves the Kelvin circulation theorem. The Lagrange multiplier for this constraint will not be Gamma_b, but s_0.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"beginbmatrix\nmathsfL  tildemathsfR  0\nmathsfE   0  mathfrak1\n0  mathfrake_k^T  0\nendbmatrix beginpmatrix mathsfs  tildemathfrakf  s_0 endpmatrix =\nbeginpmatrix -mathsfw  mathfraks_b  0 endpmatrix","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"In GridPotentialFlow.jl, we create a regularized potential flow model by specifying the index of the regularized edges using the edges keyword when creating a PotentialFlowBody. In this case, we want to regularize the trailing edge, which is the last point of Plate, so its index is length(plate).","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"pfb = PotentialFlowBody(plate,edges=[length(plate)])\nmodel = VortexModel(g,bodies=[pfb],U∞=(1.0,0.0))\nsol = solve(model);\nnothing #hide","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"When there are no vortices present in the model, the package solves the above saddle point system and the solution is the steady state solution. Inspection of the streamlines shows that flow now indeed leaves the trailing edge smoothly.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"plot(sol.ψ,g);\nplot!(plate,linecolor=:black,linewidth=2,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"By plotting the vortex sheet strength, we can see that by constraining the trailing edge point of tildemathfrakf, its whole distribution is shifted upward compared to the unregularized case such that the last value equals zero.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"plot(plot(sol.f,xlabel=\"body point index\",ylabel=\"f\",legend=false),plot(sol.f./f₀,xlabel=\"body point index\",ylabel=\"f̃\",legend=false),size=[800,300])","category":"page"},{"location":"manual/4.-The-Kutta-condition/#Using-the-Kutta-condition-to-set-a-new-vortex-element","page":"4. The Kutta condition","title":"Using the Kutta condition to set a new vortex element","text":"","category":"section"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"In the previous section, we used the Kutta condition to set the bound circulation but did not explicitly create a new vortex element. This vortex element was assumed to lie at infinity so that its effect was negligible except insofar as it left equal but opposite circulation about the body.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"In this section, we will create a new vortex element in the vicinity of the edge at which we are applying the Kutta condition. We will thus seek to establish the strength of this new element and to do so in such a manner that the overall circulation of the flow is conserved. Once the element is created, it will be allowed to advect with the local fluid velocity (minus its own contribution to this velocity).","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Let us assume that the new vortex element (which we label with the subscript 1) is introduced at some point in physical space, and that its immersion into the Cartesian grid is described by a grid vector mathsfd_1 and that its strength (i.e., its circulation) is deltaGamma_1. Thus, the fluid vorticity after this new element's introduction can be written as","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"mathsfw + deltaGamma_1 mathsfd_1","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"The vector mathsfd_1 is the discrete Dirac delta function, identical (or similar) to the function that constitutes the regularization mathsfR and interpolation mathsfE matrices.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"The Kutta condition is still to be enforced. We also seek to ensure that the total circulation is zero. (We are assuming that the flow has started from rest.) Let us denote the circulation of the existing fluid vorticity mathsfw by","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Gamma_mathsfw = Delta x  mathsf1^Tmathsfw","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"where mathsf1 is a grid vector of ones. Then, the circulation constraint is","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"mathfrak1^T mathfrakf + deltaGamma_1 + Gamma_mathsfw = 0","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"The circulation of the bound vortex sheet mathfrakf can be re-written in terms of the smooth part of the sheet as mathfrak1^T mathfrakf = mathfrakf_0 tildemathfrakf.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"With these two constraints, the overall saddle point system of equations is","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"beginbmatrix\nmathsfL  tildemathsfR  0  mathsfd_1\nmathsfE   0  mathfrak1  0\n0  mathfrake_k^T  0  0\n0  mathfrakf_0^T  0  1\nendbmatrix beginpmatrix mathsfs  tildemathfrakf  s_0  deltaGamma_1 endpmatrix =\nbeginpmatrix -mathsfw  mathfraks_b  0  -Gamma_mathsfw endpmatrix","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"To simulate this case for our flat plate, we need to insert a point vortex in the flow, preferably near the trailing edge. This situation corresponds to the flow right after impulsively starting a uniform flow around a flat plate and the point vortex now represents the starting vortex. We position the vortex behind and orthogonal the plate at a distance that is proportional to the convective length from the trailing edge. This position does not matter much here, but is of importance when we step in time and insert more point vortices every time step. Its strength can be set arbitrarily, because any vortices that are used for regularizing edges will be ignored when calculating mathsfw in the right-hand side for the saddle-point system.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Δt = 1e-2\nvTE = Vortex(plate.x[end]+3*Δt*cos(α+π/2),plate.y[end]+3*Δt*sin(α+π/2),0.0);\nnothing #hide","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"We include the point vortex when we create our model. Because the package detects that there is a vortex in the model, it solves the unsteady saddle point system and the solution will include the strength for the new point vortex.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"pfb = PotentialFlowBody(plate,edges=[length(plate)])\nmodel = VortexModel(g,bodies=[pfb],vortices=[vTE],U∞=(1.0,0.0))\nsol = solve(model);\nplot(sol.ψ,g);\nplot!(plate,linecolor=:black,linewidth=2)\nscatter!(model.vortices.x,model.vortices.y,color=:black,markersize=2,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Note that the strength of the new point vortex is not automatically set when calling solve on the vortex model","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Because of the proximity of the point vortex to the flat plate, tildemathfrakf exhibits a quick variation in its value at the surface points that lie closest to the point vortex. The value at the trailing edge point itself is still constrained to zero.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"plot(plot(sol.f,xlabel=\"body point index\",ylabel=\"f\",legend=false),plot(sol.f./f₀,xlabel=\"body point index\",ylabel=\"f̃\",legend=false),size=[800,300])","category":"page"},{"location":"manual/4.-The-Kutta-condition/#Applying-more-than-one-Kutta-condition-on-a-body","page":"4. The Kutta condition","title":"Applying more than one Kutta condition on a body","text":"","category":"section"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Suppose we wish to enforce the Kutta condition at two edges of the body–-at points k_1 and k_2–-instead of one. Each such point has a constraint,","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"mathfrake_k_j^T tildemathfrakf = 0quad j = 12","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"For two such constraints, we need two Lagrange multipliers: the strengths of two new vortices, deltaGamma_1 and deltaGamma_2, immersed into the grid with mathsfd_1 and mathsfd_2, respectively; and we still need the Lagrange multiplier s_0 to ensure that Kelvin's circulation theorem is also enforced. The system in the previous section is thus easily generalized to the following:","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"beginbmatrix\nmathsfL  tildemathsfR  0  mathsfd_1  mathsfd_2\nmathsfE   0  mathfrak1  0 0\n0  mathfrake_k_1^T  0  0  0\n0  mathfrake_k_2^T  0  0  0\n0  mathfrakf_0^T  0  1  1\nendbmatrix beginpmatrix mathsfs  tildemathfrakf  s_0  deltaGamma_1  deltaGamma_2 endpmatrix =\nbeginpmatrix -mathsfw  mathfraks_b  0  0  -Gamma_mathsfw endpmatrix","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"We now simulate this case again for our flat plate problem. This solution corresponds to the flow right after impulsively starting a uniform flow around a flat plate, but unlike the previous case, the flow now also separates at the leading edge.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"We create two vortices, one near the leading edge and one near the trailing edge.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"vLE = Vortex(plate.x[1]+3*Δt*plate.len*cos(plate.α+π/2),plate.y[1]+3*Δt*plate.len*sin(plate.α+π/2),0.0);\nvTE = Vortex(plate.x[end]+3*Δt*cos(α+π/2),plate.y[end]+3*Δt*sin(α+π/2),0.0);\nnothing #hide","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"The model now has two regularized edges, corresponding to the first body point and the last one.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"pfb = PotentialFlowBody(plate,edges=[1,length(plate)])\nmodel = VortexModel(g,bodies=[pfb],vortices=[vLE,vTE],U∞=(1.0,0.0))\nsol = solve(model);\nplot(sol.ψ,g);\nplot!(plate,linecolor=:black,linewidth=2)\nscatter!(model.vortices.x,model.vortices.y,markersize=2,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"plot(plot(sol.f,xlabel=\"body point index\",ylabel=\"f\",legend=false),plot(sol.f./f₀,xlabel=\"body point index\",ylabel=\"f̃\",legend=false),size=[800,300])","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#GridPotentialFlow.jl","page":"Home","title":"GridPotentialFlow.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A set of tools to solve potential flows past bodies on a Cartesian grid.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The objective of this package is to allow easy setup and fast simulation of potential flows. The package provides tools for","category":"page"},{"location":"","page":"Home","title":"Home","text":"constructing grids, body shapes, and point vortices,\nspecifying the relevant parameters and setting their values,\nspecifying the edges where shedding occurs and setting their suction parameter,\nsolving the problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The underlying grids are uniform and Cartesian, making use of the CartesianGrids package. This package allows the use of the lattice Green's function (LGF) for inverting the Poisson equation. The presence of bodies is accounted for using the immersed boundary projection method, originally developed for viscous flow by Taira and Colonius [1]. The potential flow system with the no-penetration condition, any edge conditions, and  Kelvin's circulation theorem is implemented with the ConstrainedSystems package. Tools for creating bodies are based on the RigidBodyTools package. The vortex dynamics are computed using the vortex-in-cell method of Christiansen [2]. For more details, please refer to Beckers, D. and Eldredge, J. D. (2021) \"Planar potential flow on Cartesian grids,\" [arXiv:2102.11910].","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: vortexshedding)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The plots in this documentation are generated using Plots.jl. You might want to install that, too, to follow the examples.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Taira, K. and Colonius, T. (2007) \"The immersed boundary method: a projection approach,\" J. Comput. Phys., 225, 2118–2137.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: Christiansen, J. (1973) \"Numerical simulation of hydrodynamics by the method of point vortices,\" J. Comput. Phys., 13, 363–379.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"EditURL = \"<unknown>/literate/6.-Force-and-the-added-mass.jl\"","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/#.-Force-and-the-added-mass","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"","category":"section"},{"location":"manual/6.-Force-and-the-added-mass/#Force","page":"6. Force and the added mass","title":"Force","text":"","category":"section"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"This part introduces the calculation of the force and moment on the body through the negative rate of change of impulse in the fluid. The continuous expressions for linear and angular impulse (about the origin) are, in two dimensions,","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"beginalign\n    boldsymbolP = int_V_f boldsymbolxtimes boldsymbolomegamathrmdV + int_S_b boldsymbolxtimes left( boldsymbolntimesboldsymbolvright)mathrmdS \n    boldsymbolPi_0 = frac12int_V_f boldsymbolxtimes left(boldsymbolxtimesboldsymbolomegaright)mathrmdV + frac12 int_S_b boldsymbolxtimes left boldsymbolxtimesleft( boldsymboln times boldsymbolv right) right mathrmdS\nendalign","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"If there is only a single body, then the force and moment (about the origin) exerted by the fluid on that body are given by","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"boldsymbolF = -rho fracmathrmdboldsymbolPmathrmdt qquad boldsymbolM_0 = -rho fracmathrmdboldsymbolPi_0mathrmdt","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"where rho is the fluid density. In the two-dimensional applications of this package, angular impulse and the moment have only a single component, e.g., boldsymbolPi_0 =Pi_0boldsymbole_z, where boldsymbole_z is the unit vector out of the plane.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/#Point-vortices-past-a-cylinder","page":"6. Force and the added mass","title":"Point vortices past a cylinder","text":"","category":"section"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"To verify our method of calculating the impulse, we create a model of two point vortices of equal and opposite circulation positioned at both sides of the x-axis, with the x-axis as axis of symmetry, and left of a circular cylinder positioned at the origin. If the top vortex has a positive circulation, the vortices propel each other towards the cylinder and convect past it. This configuration has an analytical solution for the trajecory and impulse.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"See the notebook in the examples folder for the analytical solution.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"We use a rectangular grid.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"using GridPotentialFlow\nusing Plots","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Lx = 10.0\nLy = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Ly/2,Ly/2)\ng = PhysicalGrid(xlim, ylim, 0.04)","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Rc = 1\ncircle = Circle(Rc,2*cellsize(g))\npfb = PotentialFlowBody(circle)\n\nΔs = dlength(circle);\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"The initial spacing between the vortices is y∞. After the vortices pass the cylinder, they should return to this spacing.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"y∞ = Rc/2\nv1 = Vortex(-Lx/2+10*cellsize(g),y∞,1.0);\nv2 = Vortex(-Lx/2+10*cellsize(g),-y∞,-1.0);\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"We create the vortex model with these two point vortices and the circle and advance the position of the point vortices over some time. During the time stepping, we compute the impulse with impulse and store its history.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"model = VortexModel(g,bodies=[pfb],vortices=[v1,v2])\nsol = solve(model);\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"# Analytical trajectory\nx(r) = sqrt(r^2-(y∞^2*(r^2-1)^2)/((r^2-1)^2-4*y∞^2))\ny(r) = y∞*(r^2-1)/sqrt((r^2-1)^2-4*y∞^2)\ns = 0:0.001:π/2\nrmin = 1.4375649\nc1 = rmin/(-Lx/2+rmin)\nc2 = -Lx/2*c1\nr = c2 ./ (cos.(s).-c1)\nx_trajectory = -reverse(x.(r)); append!(x_trajectory,x.(r))\ny_trajectory_upper = reverse(y.(r)); append!(y_trajectory_upper,y.(r))\ny_trajectory_lower = -y_trajectory_upper;\n# Analytical impulse\nPx_func(x,y) = y - y/(x^2+y^2) + y - y/(x^2+y^2);\nPy_func(x,y) = -x + x/(x^2+y^2) + x - x/(x^2+y^2);\nPx_exact = Px_func.(x_trajectory,y_trajectory_upper);\nPy_exact = Py_func.(x_trajectory,y_trajectory_upper);","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Δt = 0.1\nT = 0:Δt:64.0\nX_hist = []\nPx_numerical_hist = []\nPy_numerical_hist = []\n\nfor t in T\n    Ẋ = vortexvelocities!(model)\n    X = getvortexpositions(model)\n    X = X + Ẋ*Δt\n    setvortexpositions!(model,X)\n\n    push!(X_hist,X)\n\n    Px, Py = impulse(model)\n    push!(Px_numerical_hist,Px)\n    push!(Py_numerical_hist,Py)\nend","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"When we compare the trajectories and impulse history, the numerical and anaylytical solution should match closely, which is indeed the case.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"plot(circle,fillcolor=:black,fillrange=0,fillalpha=0.25,linecolor=:black,linewidth=2,xlabel=\"x\",ylabel=\"y\")\nscatter!(model.vortices.x,model.vortices.y,color=:red)\nplot!(x_trajectory,y_trajectory_upper,linecolor=:red,label=\"exact\")\nplot!(x_trajectory,y_trajectory_lower,linecolor=:red,label=\"\")\nplot!((X->X[1]).(X_hist),(X->X[3]).(X_hist),color=:blue,linestyle=:dash,label=\"simulated\")\nplot!((X->X[2]).(X_hist),(X->X[4]).(X_hist),color=:blue,linestyle=:dash,label=\"\")","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"plot(x_trajectory,Px_exact,color=:red,label=\"exact\",xlabel=\"x\",ylabel=\"Px\")\nplot!((X->X[1]).(X_hist),Px_numerical_hist,color=:blue,linestyle=:dash,label=\"simulated\")","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/#Flat-plate","page":"6. Force and the added mass","title":"Flat plate","text":"","category":"section"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"We can apply this method also to our flat plate example and compare it to the Biot-Savart method from the PotentialFlow.jl package.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"See the notebook in the examples folder for the Biot-Savart solution.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Because we create the PotentialFlow.jl model with a moving plate instead of a uniform flow, we specify a translational velocity. The GridPotentialFlow.jl model will still use a moving body coordinate system and thus a uniform flow that equals the negative translational velocity.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"c = 1.0;   # chord length\n\nċ = -1.0;  # translational velocity\nα = -π/3;   # angle of attack\n\nσLE = 0.0;\nσTE = 0.0;\n\nΔt = 5e-2;\ntf = 1.0;\nT = 0.0:Δt:tf;\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"# Potential Flow\nusing PotentialFlow\nfunction compute_ẋ!(ẋ, x, t)\n    plate, ambient_sys = x\n    motion = ẋ[1]\n    motion.ċ, motion.c̈, motion.α̇ = motion.kin(t)\n    Plates.enforce_no_flow_through!(plate, motion, ambient_sys, t)\n    reset_velocity!(ẋ, x)\n    self_induce_velocity!(ẋ, x, t)\nend\nfunction shed_new_vorticity!(blobs, plate, motion, t, lesp = 0.0, tesp = 0.0)\n    z₊ = (blobs[end-1].z + 2plate.zs[end])/3\n    z₋ = (blobs[end].z + 2plate.zs[1])/3\n    blob₊ = PotentialFlow.Vortex.Blob(z₊, 1.0, δ)\n    blob₋ = PotentialFlow.Vortex.Blob(z₋, 1.0, δ)\n    Plates.enforce_no_flow_through!(plate, motion, blobs, t)\n    Γ₊, Γ₋, _, _ = Plates.vorticity_flux!(plate, blob₊, blob₋, t, lesp, tesp);\n    push!(blobs, PotentialFlow.Vortex.Blob(z₊, Γ₊, blobs[1].δ), PotentialFlow.Vortex.Blob(z₋, Γ₋, blobs[1].δ))\nend\nN = 128 # number of plate control points (distributed along a extrema Chebyshev grid)\nδ = 0.01\nplate = PotentialFlow.Plate(N, c, zero(ComplexF64), α)\nmotion = Plates.RigidBodyMotion(ċ, 0.0);\n# Initial step\nΔz₀ = im*3Δt*exp(im*plate.α) # vectors perpendicular to the plate\nz₋, z₊ = plate.zs[[1,N]] # LE and TE\nblobs = PotentialFlow.Vortex.Blob.(Δz₀ .+ [z₊, z₋], 1.0, δ) # First two point vortices are placed close to the LE and TE with unit strength\nPlates.enforce_no_flow_through!(plate, motion, (), 0)\nΓ₊, Γ₋, _, _ = Plates.vorticity_flux!(plate, blobs[1], blobs[2], 0.0, σLE, σTE); # Determine strength of first two vortices\nblobs = PotentialFlow.Vortex.Blob.(Δz₀ .+ [z₊, z₋], [Γ₊, Γ₋], δ) # Create first two point vortices now with calculated strengths\nsys₀ = (plate, blobs)\nsys = deepcopy(sys₀)\nsys₊ = deepcopy(sys₀) # Used for storage during time-marching\nẋs = (motion, allocate_velocity(blobs))\nimp = ComplexF64[];\nt_hist = Float64[]\nglobal t = 0\npush!(t_hist,t)\n# Time stepping\nfor tloc in T[2:end]\n    global t += Δt\n    global sys\n    global sys₊\n    push!(imp,Elements.impulse(sys))\n    push!(t_hist,t)\n    local plate, ambient_ω = sys\n    local motion, ambient_u = ẋs\n    resize!(sys₊[2], length(sys[2]))\n    forward_euler!(sys₊, sys, t, Δt, compute_ẋ!, advect!, ẋs)\n    sys, sys₊ = sys₊, sys\n    shed_new_vorticity!(sys[2], sys[1], ẋs[1], t, σLE, σTE)\nend\nforce = -diff(imp)/Δt;","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Δx = 0.01\nxlim = (-0.5,2)\nylim = (-1,1)\ng = PhysicalGrid(xlim,ylim,Δx);\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"dsdx = 2\nplate = RigidBodyTools.Plate(c,dsdx*Δx)\npfb = PotentialFlowBody(plate,edges=[1,length(plate)],σ=[SuctionParameter(σLE),SuctionParameter(σTE)])\ntransform = RigidTransform((0.0,0.0),-π/3)\ntransform(plate);\nΔs = dlength(plate)\nmaximum(Δs/Δx);\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"As before, we create the initial vortices based on the time step and uniform flow and define a function that create the new point vortices for the subsequent time steps.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"firstvLE = GridPotentialFlow.Vortex(plate.x[1]+3Δt*(-ċ)*cos(plate.α+π/2),plate.y[1]+3Δt*(-ċ)*sin(plate.α+π/2),0.0);\nfirstvTE = GridPotentialFlow.Vortex(plate.x[end]+3Δt*(-ċ)*cos(plate.α+π/2),plate.y[end]+3Δt*(-ċ)*sin(plate.α+π/2),0.0);\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"function createsheddedvortices(plate,oldvortices)\n\n    vLE = GridPotentialFlow.Vortex(2/3*plate.x[1]+1/3*oldvortices[end-1].x,2/3*plate.y[1]+1/3*oldvortices[end-1].y,0.0)\n    vTE = GridPotentialFlow.Vortex(2/3*plate.x[end]+1/3*oldvortices[end].x,2/3*plate.y[end]+1/3*oldvortices[end].y,0.0)\n\n    return vLE,vTE\nend","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"The model free stream should be the negative of the translational velocity of the plate.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"model = VortexModel(g,bodies=[pfb],vortices=[firstvLE,firstvTE],U∞=(-ċ,0.0));\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Note that we have to set the strengths of the new vortices ourselves before calling the impulse function. In this case, this is done for us in the vortexvelocities!.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Px_hist = Float64[];\nPy_hist = Float64[];\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Then we enter a time loop and record the impulse every time we create new vortices.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"for tloc in T[2:end]\n    Ẋ = vortexvelocities!(model)\n    Px, Py = impulse(model)\n    X = getvortexpositions(model)\n    X = X + Ẋ*Δt\n    setvortexpositions!(model,X)\n    vLE, vTE = createsheddedvortices(plate,model.vortices)\n    pushvortices!(model,vLE,vTE)\n    push!(Px_hist,Px)\n    push!(Py_hist,Py)\nend","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"The force history can be obtained by finite differencing the impulse history.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Fx_hist = -diff(Px_hist)/Δt;\nFy_hist = -diff(Py_hist)/Δt;\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"We can now compare the positions of the point vortices by shifting the PotentialFlow.jl solution by -tf*ċ such that the origin of the frame of reference coincides with the center plate. Superimposingt the GridPotentialFlow.jl solution then shows that the positions of the point vortices agree very well.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"plot(plate,fillcolor=:black,fillrange=0,fillalpha=0.25,linecolor=:black,linewidth=2,xlim=xlim,ylim=ylim,xlabel=\"x\",ylabel=\"y\")\nscatter!(real.((v->v.z).(sys[2])).-tf*ċ,imag.((v->v.z).(sys[2])),color=:red,markersize=4,label=\"PotentialFlow.jl\")\nscatter!(model.vortices.x,model.vortices.y,color=:blue,markersize=2,label=\"GridPotentialFlow.jl\")","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"The vertical impulse and the vertical force (lift) can also be compared and show good agreement as well.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"plot(xlabel=\"t\",ylabel=\"Py\")\nplot!(T[1:end-1],imag.(imp),color=:blue,label=\"PotentialFlow.jl\")\nplot!(T[1:end-1],Py_hist,color=:red,label=\"GridPotentialFlow.jl\")","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"plot(xlabel=\"t\",ylabel=\"Fy\")\nplot!(T[2:end-1],imag.(force),color=:blue,label=\"PotentialFlow.jl\")\nplot!(T[2:end-1],Fy_hist,color=:red,label=\"GridPotentialFlow.jl\")","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/#Added-mass","page":"6. Force and the added mass","title":"Added mass","text":"","category":"section"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"The added mass tensor provides a measure of the inertial influence of the fluid on the body in response to changes in the body's translational or rotational motion. The coefficients of the added mass tensor of a body are obtained by computing the impulse components associated with a unit-valued component of motion. The motion's influence is both direct, via the surface velocity, and indirect, in the bound vortex sheet that develops on the surface.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"The added mass for simple geometries can easiliy be calculated in an analytical way. For example, the entries of the translational added mass tensor for an ellipse with semi-major axis a and semi-minor axis b are m_xx = rho pi b^2 for motion in the x direction, m_yy = rho pi a^2 for motion in the y-direction, with the diagonal entries m_xy=m_yx=0. By using addedmass from this package we can approximate these results numerically. In this case, we have one body and the method will return a matrix with the entries","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"beginbmatrix\nm_xx  m_xy \nm_yx  m_yy\nendbmatrix","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Lx = 2.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,0.01)\nΔx = cellsize(g);","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"a = 0.5\nb = 0.25\nellipse = Ellipse(a,b,Δx)\npfb = PotentialFlowBody(ellipse)\nmodel = VortexModel(g,bodies=[pfb])\nM = GridPotentialFlow.addedmass(model)","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"We can compare the values using the @test macro.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"using Test\n@test isapprox(M[1,1], π*b^2, rtol=1e-1)","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"@test isapprox(M[2,2], π*a^2, atol=1e-1)","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"In the case of N bodies, addedmass returns the translational added mass tensor of size 2N-by-2N. As an example, we will compute the added mass tensor for an array of cylinders. To compare it with an analytically obtained solution, we will calculate the added mass matrix tensor for the following gap-to-radius ratios.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"GRratios = [0.1,0.2,0.3,0.4,0.5,0.6,0.8,1.0,1.2,1.4,1.6];\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"function rectangulararray(rows,columns,spacing)\n    centers = VectorData(rows*columns)\n    for j in 1:columns\n        for i in 1:rows\n            xc = (i-1)*spacing\n            yc = (j-1)*spacing\n            centers.u[(j-1)*rows+i] = xc\n            centers.v[(j-1)*rows+i] = yc\n        end\n    end\n    centers.u .-= mean(centers.u)\n    centers.v .-= mean(centers.v)\n    return centers\nend","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"For this case, the array consists of three rows of three cylinders.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"n = 100\nrows = 3\ncolumns = 3\nN = rows*columns\nR = 0.20\n𝒱 = π*R^2\nbodies = fill(Circle(R,2*cellsize(g)),N);\nΔs = minimum(dlength(bodies[1]));\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"We loop over the gap-to-radius ratios, position the bodies, and compute the ratio of the largest eigenvalue to the largest diagonal element of the translational added mass tensor. To position the bodies, we defined the method rectangulararray (see notebook in the examples folder).","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"using Statistics: mean\nusing LinearAlgebra: eigen","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"λoverMratios = zeros(length(GRratios))\nfor idx in 1:length(GRratios)\n    global bodies\n    gap = GRratios[idx]*R\n    spacing = 2*R+gap\n    bodycenters = rectangulararray(rows,columns,spacing)\n    for i in 1:N\n        Tf = RigidTransform((bodycenters.u[i],bodycenters.v[i]),0.0)\n        global bodies[i] = Tf(deepcopy(bodies[i]))\n    end\n    body_list = PotentialFlowBody.(bodies)\n    vm = VortexModel(g,bodies=body_list);\n    M = GridPotentialFlow.addedmass(vm)/𝒱\n    eigM = eigen(M);\n    max_eig_value_coef = maximum(real(eigM.values))\n    max_self_added_mass_coef = maximum(M)\n    λoverMratios[idx] = max_eig_value_coef/max_self_added_mass_coef\nend","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"The same ratios, obtained in an analytical way, are available in literature [1] and can be used to verify the numerical values.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"nineRodArrayChen = [2.3637,2.2092,2.1007,2.0120,1.9350,1.8665,1.7494,1.6531,1.5732,1.5066,1.4508];\nplot(xlabel=\"GR\",ylabel=\"λ/max(Mij)\")\nplot!(GRratios,nineRodArrayChen,label=\"Chen1975\")\nplot!(GRratios,λoverMratios,label=\"GridPotentialFlow.jl\")","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"[1]: Chen, S. S. (1975) \"Vibration of nuclear fuel bundles,\" Nuclear Engineering and Design, 35 (3), 399-–422.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"This page was generated using Literate.jl.","category":"page"}]
}
