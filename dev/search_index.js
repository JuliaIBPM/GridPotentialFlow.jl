var documenterSearchIndex = {"docs":
[{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"EditURL = \"<unknown>/literate/1.-Basic-potential-flow-problem.jl\"","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/#.-Basic-potential-flow-problem","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"","category":"section"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"This part introduces how to solve the basic potential flow problem in this package. We consider here a staggered, Cartesian grid with uniform cell size and of infinite extent. The basic (unbounded) potential flow problem is expressed as","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"mathsfLs = -mathsfw","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"where mathsfL is the discrete 5-point Laplacian operator, mathsfs is the discrete streamfunction, and mathsfw is the discrete vorticity. Following the vortex-in-cell approach, the discrete vorticity is obtained by regularizing the vorticity from the N_v vortex elements onto the cell vertices,","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"mathsfw_i j=sum_q=1^N_v frac1Delta x Gamma_v q dleft(fracmathsfx_i-X_qDelta xright) dleft(fracmathsfy_j-Y_qDelta xright)","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"where d is the M_4 interpolation kernel, and (X_qY_q) and Gamma_vq are the position and strength of the qth vortex element.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/#Flow-around-a-point-vortex","page":"1. Basic potential flow problem","title":"Flow around a point vortex","text":"","category":"section"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"Now we will solve this discrete potential flow problem using GridPotentialFlow.jl to obtain the streamfunction field and velocity field around a single point vortex.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"The first step in creating any GridPotentialFlow model is to create a PhysicalGrid to discretize the domain.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"using GridPotentialFlow\nΔx = 0.01\nLx = 2.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx);\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"The second step is to create our point vortex using Vortex.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"v = Vortex(0.0,0.0,1.0);\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"Now we can create a VortexModel using the grid and an array containing the point vortex.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"model = VortexModel(g,vortices=[v]);\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"The discrete streamfunction s is then obtained using computeψ.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"s = computeψ(model);\nusing Plots\nplot(s,g,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"The function computeψ returns a Nodes array. If we want to perform differential calculus operations this data, we can use the methods of the  CartesianGrids package. For example, we can easily obtain the velocity field from the streamfunction field using the curl operation.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"q = curl(s);\nplot(q,g,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/#Accuracy-of-the-discretized-Poisson-equation","page":"1. Basic potential flow problem","title":"Accuracy of the discretized Poisson equation","text":"","category":"section"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"To verify that the discretization technique of the Poisson equation is second-order accurate, we perform a mesh refinement analysis for a flow consisting of point vortices of random strenght that are randomly positioned on the lower-left quadrant of a square domain.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"The error is calculated by comparing the numerically calculated streamfunction field with the exact solution for the streamfunction field. We therefore need a function to calculate the exact streamfunction.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"function ψVortex!(ψ::Nodes{Dual,nx,ny},vortex::Vortex,g::PhysicalGrid) where {nx,ny}\n    x,y = coordinates(ψ,g)\n    for i in 2:nx-1, j in 2:ny-1\n        r = sqrt((x[i]-vortex.x)^2+(y[j]-vortex.y)^2)\n        ψ[i,j] = ψVortex(r,vortex.Γ)\n    end\nend\n\nfunction ψVortex(r::Real,Γ::Real)\n    return -Γ/(2π)*log(r)\nend","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"We create four vortices with random strenghts, randomly positioned in the lower-left quadrant of the domain.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"nv = 4;\nvl = VortexList(Vortex.(-Lx/4 .+ 0.4*Lx*(rand(nv).-0.5),-Lx/4 .+ 0.4*Lx*(rand(nv).-0.5),0.5*rand(nv).+0.5));\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"Next, we create a series of grids, with each grid doubling the number of grid points of the previous grid in each direction.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"grids = [PhysicalGrid(xlim,ylim,Lx/(nx-2)) for nx in [2^p for p in 5:9]];\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"The error is calculated as epsilon = Vert psi(mathsfxmathsfy)Delta x - mathsfs Vert_2  Vert mathsfs Vert_2, for which we use the norm function.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"using LinearAlgebra: norm","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"We now loop over the grids and calculate the error.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"errors = []\ngridspacings = []\nfor g in grids\n    # LGF\n    model = VortexModel(g,vortices=vl)\n    s_lgf = computeψ(model);\n\n    # Exact solution\n    s_exact = Nodes(Dual,size(g))\n    s_temp = Nodes(Dual,size(g))\n    for v in vl\n        ψVortex!(s_temp,v,g)\n        s_exact += s_temp\n    end\n\n    # Bring to same reference level. A constant value can be added/subtracted to any potential flow solution\n    s_lgf .-= s_lgf[g.I0[1],2];\n    s_exact .-= s_exact[g.I0[1],2];\n\n    error = s_lgf-s_exact\n    idx = g.I0[1] + 1 : g.N[1] - 1 # Only look at top right corner\n    push!(errors,norm(error[idx,idx])/norm(s_lgf[idx,idx]))\n    push!(gridspacings,g.Δx)\nend","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"And finally, we create a log-log plot of the error versus the grid spacing.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"firstorder=(errors[end]/gridspacings[end].*gridspacings).^1\nsecondorder=(sqrt(errors[end])/gridspacings[end].*gridspacings).^2\np=plot(gridspacings,errors,xaxis=:log,yaxis=:log,marker=:circle,lab=\"error\",xlabel=\"dx\",legend=:bottomright,title=\"Error\")\nplot!(gridspacings,firstorder,lab=\"1st order\",linestyle=:dot,linecolor=:black)\nplot!(gridspacings,secondorder,lab=\"2nd order\",linestyle=:dash,linecolor=:black)","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/#Corotating-point-vortices","page":"1. Basic potential flow problem","title":"Corotating point vortices","text":"","category":"section"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"Now we will try advancing a vortex model in time. The simplest unsteady vortex model consists of two point vortices. When both point vortices have the same strength, they will rotate around each other on a trajectory that is easy to describe analytically. In this example, we will compare the analytical and simulated trajectories during one revolution.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"First create two vortices at a distance d from each other and give them a strength Gamma","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"d = Lx/2\nΓ = 1\nv1 = Vortex(d/2,0.0,Γ);\nv2 = Vortex(-d/2,0.0,Γ);\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"We can analytically determine the time T_v it takes for these vortices to complete one revolution around their centroid.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"Vθ = Γ/(2*π*d); # Analytical tangential velocity\nTv = π*d/Vθ; # Analytical period\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"Let's now create a vortex model with the two point vortices.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"model = VortexModel(g,vortices=[v1,v2]);\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"If we update the positions of the point vortices repeatedly to simulate the model advancing in time from t=0 to t=T_v, we can check if they end up again at their original positions.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"Δt = 0.005;\nT = 0:Δt:Tv;\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"To step in time, we update the position of the qth vortex as X^n+1_q = X^n_q + Δt X^n_q (forward Euler) in a for-loop. The flow velocity at the locations of the vortices X is obtained with computevortexvelocities, which regularizes the vorticity to the grid, solves the potential flow system, and interpolates the velocities from the grid to the vortex locations as","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"left(U_q V_qright)=sum_i j mathsfv_i j dleft(fracmathsfx_i-X_qDelta xright)left(fracmathsfy_j-Y_qDelta xright)","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"where v is the velocity field on the nodes.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"X_hist = []\nfor t in T\n    Ẋ = computevortexvelocities(model)\n    X = getvortexpositions(model)\n    X = X + Ẋ*Δt\n    setvortexpositions!(model,X)\n    push!(X_hist,X)\nend\n\nψ = computeψ(model);\nplot(ψ,g)\nscatter!(model.vortices,color=:red)\nplot!((X->X[1]).(X_hist),(X->X[3]).(X_hist),color=:blue,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/#Corotating-vortex-patches","page":"1. Basic potential flow problem","title":"Corotating vortex patches","text":"","category":"section"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"A more complex example is the evolution of two circular regions of spatially uniform vorticity that have an equal radius r_0 and strength Gamma, and whose centers are separated by a distance d_0. Note that if these were two point vortices, their period would be equal to 2 pi^2 d_0^2  Gamma_0, so we will take the final time of our simulation equal to this to ensure it includes one period.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"Γ0 = 1.0;\nd0 = 1.0;\ntf = 2*π^2*d0^2/Γ0;\ntspan = (0.0,tf);\nnothing #hide","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"To simulate their evolution, we discretize these vortex patches with point vortices arranged on concentric rings using the following function.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"function vortexpatch!(vort,xc::Float64,yc::Float64,Γ,radius,nring::Int)\n    Δr = radius/(nring-1/2)\n    dΓ = Γ/(1+8*nring*(nring-1)/2)\n    push!(vort,Vortex(xc,yc,dΓ))\n    for ir in 1:nring-1\n        nθ = 8*ir\n        for j = 0:nθ-1\n            push!(vort,Vortex(xc + ir*Δr*cos(2π*j/nθ),yc + ir*Δr*sin(2π*j/nθ),dΓ))\n        end\n    end\n    return vort\nend\n\nvortexpatch(xc,yc,Γ,radius,nring::Int) = vortexpatch!(Vortex[],xc,yc,Γ,radius,nring)","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"xlim = (-2,2);\nylim = (-2,2);\nΔx = 0.05;\ng = PhysicalGrid(xlim,ylim,Δx);","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"In our last example, we implemented a forward Euler time stepping routine. In this example, we will make use of the fourth-order Runge-Kutta time stepping algorithm of OrdinaryDiffEq.jl to get more accurate results.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"using OrdinaryDiffEq","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"To construct the ODEProblem from this package, we will have to provide a right-hand side function.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"function rhs(X,model,t)\n    setvortexpositions!(model,X)\n    Ẋ = computevortexvelocities(model)\n    return Ẋ\nend","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"We will simulate two cases with different values for r_0d_0, the ratio of the vortex patch radius to the distance between them.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"r0 = 0.2*d0;\nvortices = vcat(vortexpatch(0.0,0.0+d0/2,Γ0,r0,10),vortexpatch(0.0,0.0-d0/2,Γ0,r0,10));\nvortexcolors = vcat(fill(:blue,length(vortices)÷2),fill(:red,length(vortices)÷2));\nmodel = VortexModel(g,vortices=vortices);\nX = getvortexpositions(model)\nprob = ODEProblem(rhs,X,tspan,model);\nsol = solve(prob,dt=0.1,RK4(),dense=false,adaptive=false);\nanimation = @gif for i=1:length(sol.t)-1\n    plot(xlims=xlim,ylims=ylim,ratio=:equal,legend=:none,title=\"r0/d0 = $(r0/d0)\")\n    scatter!(sol.u[i].u,sol.u[i].v,markerstrokewidth=0,markersize=3,color=vortexcolors)\nend","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"If the ratio r_0d_0 is big enough, the two vortex patches merge with eachother, a result that has been widely reported in literature [1].","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"r0 = 0.4*d0;\nvortices = vcat(vortexpatch(0.0,0.0+d0/2,Γ0,r0,10),vortexpatch(0.0,0.0-d0/2,Γ0,r0,10));\nvortexcolors = vcat(fill(:blue,length(vortices)÷2),fill(:red,length(vortices)÷2));\nmodel = VortexModel(g,vortices=vortices);\nX = getvortexpositions(model)\nprob = ODEProblem(rhs,X,tspan,model);\nsol = solve(prob,dt=0.1,RK4(),dense=false,adaptive=false);\nanimation = @gif for i=1:length(sol.t)-1\n    plot(xlims=xlim,ylims=ylim,ratio=:equal,legend=:none,title=\"r0/d0 = $(r0/d0)\")\n    scatter!(sol.u[i].u,sol.u[i].v,markerstrokewidth=0,markersize=3,color=vortexcolors)\nend","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"[1]: Eldredge J. D. (2019) \"Mathematical  Modeling  of  Unsteady  Inviscid  Flows, Interdisciplinary Applied Mathematics\" Springer, vol. 50.","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"","category":"page"},{"location":"manual/1.-Basic-potential-flow-problem/","page":"1. Basic potential flow problem","title":"1. Basic potential flow problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"private/#Private-Documentation","page":"Private Documentation","title":"Private Documentation","text":"","category":"section"},{"location":"private/","page":"Private Documentation","title":"Private Documentation","text":"Documentation for GridPotentialFlow.jl's private interface.","category":"page"},{"location":"private/","page":"Private Documentation","title":"Private Documentation","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"private/#Contents","page":"Private Documentation","title":"Contents","text":"","category":"section"},{"location":"private/","page":"Private Documentation","title":"Private Documentation","text":"Pages = [\"private.md\"]","category":"page"},{"location":"private/#Index","page":"Private Documentation","title":"Index","text":"","category":"section"},{"location":"private/","page":"Private Documentation","title":"Private Documentation","text":"Pages = [\"private.md\"]","category":"page"},{"location":"private/#Private-Interface","page":"Private Documentation","title":"Private Interface","text":"","category":"section"},{"location":"private/","page":"Private Documentation","title":"Private Documentation","text":"Modules = [GridPotentialFlow]\nPublic = false","category":"page"},{"location":"private/#Base.collect-Tuple{VortexList}","page":"Private Documentation","title":"Base.collect","text":"collect(vl::VortexList) -> Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}\n\n\nCollect the inertial-space coordinates and strengths of all of the Lagrange points comprising the vortices in vortex list vl and return each assembled set as a vector.\n\n\n\n\n\n","category":"method"},{"location":"private/#GridPotentialFlow.setposition!-Tuple{Vortex,Real,Real}","page":"Private Documentation","title":"GridPotentialFlow.setposition!","text":"setposition!(vortex::Vortex, xnew::Real, ynew::Real) -> Vortex\n\n\nSets the x and y fields of vortex to the xnew and ynew, respectively.\n\n\n\n\n\n","category":"method"},{"location":"private/#GridPotentialFlow.setpositions!-Tuple{VortexList,Any,Any}","page":"Private Documentation","title":"GridPotentialFlow.setpositions!","text":"setpositions!(vortices::VortexList, xpositions::Any, ypositions::Any) -> Any\n\n\nSets the x and y fields of the point vortices in vortices to the entries of xpositions and ypositions, respectively.\n\n\n\n\n\n","category":"method"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"EditURL = \"<unknown>/literate/3.-Non-uniqueness-and-discrete-circulation.jl\"","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/#.-Non-uniqueness-and-discrete-circulation","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"","category":"section"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"There is no unique solution to the two-dimensional potential flow problem in the presence of an impenetrable surface, since one can choose any value for the uniform value mathfraks_0 and still enforce the no-penetration condition. Equivalently, we can specify any circulation about the body and still enforce this condition. For later use, let us write this uniform surface streamfunction as mathfraks_0 = s_0 mathfrak1, where s_0 is a single scalar value and mathfrak1 is a vector of ones on all surface points. The discrete circulation Gamma_b about the body is given by the sum of the bound vortex sheet data and can be written compactly as","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"Gamma_b = mathfrak1^T mathfrakf","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"In GridPotentialFlow.jl, the user cannot specify s_0 directly. Instead, the package solves the system","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"beginbmatrix\nmathsfL  mathsfR  0\nmathsfE   0  mathfrak1\n0  mathfrak1^T  0\nendbmatrix beginpmatrix mathsfs  mathfrakf  s_0 endpmatrix =\nbeginpmatrix -mathsfw  mathfraks_b  0 endpmatrix","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"and the circulation can be specified in ModelParameters. If it is not specified, it is set equal to the opposite of the circulation in the flow in the case of a single body, or zero for each body in the case of multiple bodies. The return value of solvesystem has a field ψ₀, which represents the value for s_0, in this case the Lagrange multiplier to enforce the specified circulation.","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"We now illustrate how to specify the circulation by simulating the flow around two cylinders that have different circulations.","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"using GridPotentialFlow\nusing Plots","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"Δx = 0.01\nLx = 2.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx);\nnothing #hide","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"The two cylinders are positioned using the tools from RigidBodyTools.jl.","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"R = Lx/8;\nleftcircle = Circle(R,Δx)\nT = RigidTransform((-Lx/4,0.0),0.0)\nT(leftcircle);\nrightcircle = Circle(R,Δx)\nT = RigidTransform((Lx/4,0.0),0.0)\nT(rightcircle);\nnothing #hide","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"The circulations are specified in the ModelParameters using the Γb keyword.","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"model = VortexModel(g,bodies=[leftcircle,rightcircle])\nmodelparameters = ModelParameters(Γb=[1.0,0.0])\ns = computeψ(model,parameters=modelparameters)\nplot(s,g)\nplot!(leftcircle,fillcolor=:black,fillrange=0,fillalpha=0.25,linecolor=:black,linewidth=2)\nplot!(rightcircle,fillcolor=:black,fillrange=0,fillalpha=0.25,linecolor=:black,linewidth=2)","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"When the previously introduced saddle point system","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"beginbmatrix\nmathsfL  mathsfR \nmathsfE   0\nendbmatrix beginpmatrix mathsfs  mathfrakf endpmatrix =\nbeginpmatrix -mathsfw  mathfraks_b - mathfraks_0 endpmatrix","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"is solved, the resulting circulation is","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"Gamma_b = mathfrak1^T mathsfS^-1left(mathfraks_b^prime+mathsfEL^-1 mathsfwright)-s_0 mathfrak1^T mathsfS^-1 mathfrak1","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"where mathsfS = -mathsfEL^-1mathsfR is the Schur complement. The scalar factor mathfrak1^T mathsfS^-1 mathfrak1 in this expression is a property of the set of points and their immersion into the Cartesian grid. Part of this factor, mathsfS^-1 mathfrak1, represents the bound vortex sheet strength associated with a uniform, unit-strength streamfunction on the surface. This sheet has a particularly important role in some of the discussion to follow, so we will denote its strength by mathfrakf_0:","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"mathfrakf_0 equiv mathsfS^-1 mathfrak1","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"We demonstrate below the distribution of mathfrakf_0 for elliptical cylinders with different aspect ratios.","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"Δx = 0.004\nLx = 2.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx);\nnothing #hide","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"Let us consider four cylinders with aspect ratios 1, 2, 3, and infinity. An ellipse with infinite aspect ratio is a flat plate, so we construct that case separately.","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"a = Lx/4 # semi-major axis\nAR_list = [1.0,2.0,3.0]\nellipses = [Ellipse(a,a/AR,Δx) for AR in AR_list]\nbodies = Body[]\npush!(bodies,[SplinedBody(hcat(body.x,body.y),3*cellsize(g)) for body in ellipses]...)\npush!(bodies,Plate(2*a,3*Δx));\ncolors = [:blue,:red,:green,:black]\nplot()\nfor i in 1:length(bodies)\n    plot!(bodies[i],fillrange=0,fillalpha=0.0,linecolor=colors[i],linewidth=2)\nend\nplot!(xlim=xlim,ylim=ylim,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"To compute mathfrakf_0, we have to access the internal fields of the associated system of our vortexmodel.","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"f₀_list = []\nfor i in 1:length(bodies)\n    Δs = dlength(bodies[i]);\n    model = VortexModel(g,bodies=[bodies[i]]);\n    ones = ScalarData(length(bodies[i]))\n    ones .= 1.0\n    f₀ = model.system.S.S⁻¹*ones\n    push!(f₀_list,f₀)\nend","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"Because the flat plate is an open body, we need to mirror and append its contents to itself to compare it to the ellipses. Furthermore, its bound vortex sheet strength should be divided by two because it represents gamma = gamma^+ + gamma^-","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"append!(f₀_list[end],reverse!(f₀_list[end]));\nΔs_plate = dlengthmid(bodies[end]);\nappend!(Δs_plate,reverse!(Δs_plate));\nplot(ylim=(-2,0),xlabel=\"p/N\",title=\"f₀ for ellipses of different aspect ratios\")\nfor i in 1:length(bodies)-1\n    plot!((1:length(f₀_list[i]))/length(f₀_list[i]),f₀_list[i]./dlength(bodies[i]),linecolor=colors[i],label=\"AR=$(AR_list[i])\")\nend\nplot!((1:length(f₀_list[end]))/length(f₀_list[end]),0.5*f₀_list[end]./Δs_plate,linecolor=colors[end],label=\"AR=inf\")","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"","category":"page"},{"location":"manual/3.-Non-uniqueness-and-discrete-circulation/","page":"3. Non-uniqueness and discrete circulation","title":"3. Non-uniqueness and discrete circulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"public/#Public-Documentation","page":"Public Documentation","title":"Public Documentation","text":"","category":"section"},{"location":"public/","page":"Public Documentation","title":"Public Documentation","text":"Documentation for GridPotentialFlow.jl's public interface.","category":"page"},{"location":"public/","page":"Public Documentation","title":"Public Documentation","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"public/#Contents","page":"Public Documentation","title":"Contents","text":"","category":"section"},{"location":"public/","page":"Public Documentation","title":"Public Documentation","text":"Pages = [\"public.md\"]","category":"page"},{"location":"public/#Index","page":"Public Documentation","title":"Index","text":"","category":"section"},{"location":"public/","page":"Public Documentation","title":"Public Documentation","text":"Pages = [\"public.md\"]","category":"page"},{"location":"public/#Public-Interface","page":"Public Documentation","title":"Public Interface","text":"","category":"section"},{"location":"public/","page":"Public Documentation","title":"Public Documentation","text":"Modules = [GridPotentialFlow]\nPrivate = false","category":"page"},{"location":"public/#GridPotentialFlow.ModelParameters","page":"Public Documentation","title":"GridPotentialFlow.ModelParameters","text":"struct ModelParameters\n\nDefines the model parameters for VortexModel.\n\nFields\n\nUb::Union{Nothing, AbstractArray}\nUb: Array that contains the velocity of each body or nothing if there is no body. Each entry should be a collection of the x- and y-components of the velocity.\nU∞::Any\nU∞: Collection of the x- and y-components of the free stream velocity.\nΓb::Union{Nothing, AbstractArray}\nΓb: Array that contains the desired circulation of each body or nothing if there is no body. This will only be enforced if the body has no regularized edges.\nσ::Union{Nothing, AbstractArray{Union{Float64, SuctionParameterRange},N} where N}\nσ: Array that contains the suction parameter or suction parameter range for each edge or nothing if there are no regularized edges or if the Kutta condition is to be enforced.\n\n\n\n\n\n","category":"type"},{"location":"public/#GridPotentialFlow.ModelParameters-Tuple{}","page":"Public Documentation","title":"GridPotentialFlow.ModelParameters","text":"ModelParameters(; Ub, U∞, Γb, σ) -> ModelParameters\n\n\nConstructs the parameters for a vortex model using the given function.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.Vortex","page":"Public Documentation","title":"GridPotentialFlow.Vortex","text":"mutable struct Vortex\n\nDefines a point vortex with x-position x, y-position y, and strength Γ.\n\nFields\n\nx::Float64\nx: x-coordinate of the vortex position.\ny::Float64\ny: y-coordinate of the vortex position.\nΓ::Float64\nΓ: Strength of the vortex. Positive if counter-clockwise.\n\n\n\n\n\n","category":"type"},{"location":"public/#GridPotentialFlow.VortexList","page":"Public Documentation","title":"GridPotentialFlow.VortexList","text":"struct VortexList\n\nDefines a list of point vortices.\n\nFields\n\nlist::Array{Vortex,1}\nlist: Array of point vortices.\n\n\n\n\n\n","category":"type"},{"location":"public/#GridPotentialFlow.VortexModel","page":"Public Documentation","title":"GridPotentialFlow.VortexModel","text":"mutable struct VortexModel{Nb, Ne, isshedding}\n\nDefines a grid-based vortex model with Nb bodies and Ne edges that are regularized. If isshedding is true, the strengths of the last Ne vortices in vortices can be computed in order to regularized the Ne edges.\n\nFields\n\ng::PhysicalGrid\ng: The grid on which the vortex model is defined.\nbodies::BodyList\nbodies: Bodies in the vortex model.\nvortices::VortexList\nvortices: Point vortices in the vortex model.\nedges::Array{Int64,1}\nedges: Array of body points where shedding occurs.\nsystem::PotentialFlowSystem\nsystem: Potential flow system that has to be solved with a PotentialFlowRHS and a PotentialFlowSolution to compute the potential flow that governs the vortex model.\n\n_nodedata::Nodes{Dual,NX,NY,T,DT} where DT<:(AbstractArray{T,2} where T) where T<:Number where NY where NX\nInternal fields\n_edgedata::Edges{Primal,NX,NY,T,DT} where DT where T<:Number where NY where NX\n_bodydata::ScalarData\n_bodyvectordata::VectorData\n_d::Nodes{Dual,NX,NY,T,DT} where DT<:(AbstractArray{T,2} where T) where T<:Number where NY where NX\n_d_kvec::Array{Nodes{Dual,NX,NY,T,DT} where DT<:(AbstractArray{T,2} where T) where T<:Number where NY where NX,1}\n_ψ::Nodes{Dual,NX,NY,T,DT} where DT<:(AbstractArray{T,2} where T) where T<:Number where NY where NX\n_f::ScalarData\n_w::Nodes{Dual,NX,NY,T,DT} where DT<:(AbstractArray{T,2} where T) where T<:Number where NY where NX\n_ψb::ScalarData\n\nExamples\n\n(under construction)\n\n\n\n\n\n","category":"type"},{"location":"public/#GridPotentialFlow.VortexModel-Tuple{PhysicalGrid}","page":"Public Documentation","title":"GridPotentialFlow.VortexModel","text":"VortexModel(g::PhysicalGrid; bodies, vortices, edges) -> VortexModel{_A,_B,_C} where _C where _B where _A\n\n\nConstructs a vortex model using the given function.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.computeaddedmassmatrix-Union{Tuple{VortexModel{Nb,Ne,isshedding} where isshedding}, Tuple{Ne}, Tuple{Nb}} where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.computeaddedmassmatrix","text":"Computes the translational coefficients of the added mass matrix of the bodies in vortexmodel.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.computeimpulse-Tuple{VortexModel}","page":"Public Documentation","title":"GridPotentialFlow.computeimpulse","text":"computeimpulse(vortexmodel; parameters)\n\n\nComputes the impulse associated with the current state vortices and bodies in vortexmodel.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.computeimpulse-Union{Tuple{Ne}, Tuple{Nb}, Tuple{VortexModel{Nb,Ne,isshedding} where isshedding,Nodes{Dual,NX,NY,T,DT} where DT<:(AbstractArray{T,2} where T) where T<:Number where NY where NX,ScalarData,Any}} where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.computeimpulse","text":"computeimpulse(vortexmodel, wphysical, fphysical, Ubvec)\n\n\nComputes the impulse associated with the vorticity wphysical, the bound vortex sheet strength fphysical, and the velocities Ubvec of the discrete points of the bodies in vortexmodel.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.computevortexvelocities-Union{Tuple{Ne}, Tuple{Nb}, Tuple{VortexModel{Nb,Ne,isshedding} where isshedding,Nodes{Dual,NX,NY,T,DT} where DT<:(AbstractArray{T,2} where T) where T<:Number where NY where NX}} where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.computevortexvelocities","text":"computevortexvelocities(vortexmodel, ψ)\n\n\nReturns the flow velocity as VectorData at the locations of the vortices stored in vortexmodel associated with the discrete vector potential field ψ.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.computevortexvelocities-Union{Tuple{VortexModel{Nb,Ne,isshedding} where isshedding}, Tuple{Ne}, Tuple{Nb}} where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.computevortexvelocities","text":"Returns the flow velocity as VectorData at the locations of the vortices stored in vortexmodel, accounting for bodies in vortexmodel and conditions in kwargs. If the vortexmodel has Ne regularized edges and vortices, the strengths of the last Ne vortices will be computed and set in vortexmodel.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.computew!-Union{Tuple{Ne}, Tuple{Nb}, Tuple{Nodes{Dual,NX,NY,T,DT} where DT<:(AbstractArray{T,2} where T) where T<:Number where NY where NX,VortexModel{Nb,Ne,isshedding} where isshedding}} where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.computew!","text":"computew!(wphysical, vortexmodel)\n\n\nComputes the vorticity field w associated with the vortices stored in vortexmodel on the physical grid.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.computew-Union{Tuple{VortexModel{Nb,Ne,isshedding} where isshedding}, Tuple{Ne}, Tuple{Nb}} where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.computew","text":"computew(vortexmodel)\n\n\nComputes the vorticity field associated with the vortices stored in vortexmodel on the physical grid.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.computeψ-Tuple{VortexModel}","page":"Public Documentation","title":"GridPotentialFlow.computeψ","text":"computeψ(vortexmodel; kwargs...)\n\n\nComputes and returns the stream function field on the physical grid for the potential flow associated with the current state of vortexmodel. A uniform flow, body velocities, bound circulation values for the unregularized bodies, and suction parameters for regularized bodies can be specified using the parameters keyword.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.getpositions-Tuple{VortexList}","page":"Public Documentation","title":"GridPotentialFlow.getpositions","text":"getpositions(vortices::VortexList) -> VectorData{_A,Float64,Array{Float64,1}} where _A\n\n\nReturns the positions of all point vortices in vortices as VectorData.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.getstrengths-Tuple{VortexList}","page":"Public Documentation","title":"GridPotentialFlow.getstrengths","text":"getstrengths(vortices::VortexList) -> ScalarData{_A,Float64,Array{Float64,1}} where _A\n\n\nReturns the strengths of all point vortices in vortices as ScalarData.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.getvortexpositions-Union{Tuple{VortexModel{Nb,Ne,isshedding} where isshedding}, Tuple{Ne}, Tuple{Nb}} where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.getvortexpositions","text":"Returns the positions of the vortices in vortexmodel.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.pushvortices!-Union{Tuple{Ne}, Tuple{Nb}, Tuple{VortexModel{Nb,Ne,isshedding} where isshedding,Vararg{Any,N} where N}} where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.pushvortices!","text":"pushvortices!(vortexmodel, newvortices)\n\n\nAdds the newvortices to the existing vortices in vortexmodel.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.setvortexpositions!-Union{Tuple{Nv}, Tuple{Ne}, Tuple{Nb}, Tuple{VortexModel{Nb,Ne,isshedding} where isshedding,VectorData{Nv,T,DT} where DT<:(AbstractArray{T,1} where T) where T}} where Nv where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.setvortexpositions!","text":"setvortexpositions!(vortexmodel, X_vortices)\n\n\nSets the positions of the vortices in vortexmodel to the provided X_vortices.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.setvortices!-Union{Tuple{VortexModel{Nb,Ne,isshedding} where isshedding}, Tuple{Ne}, Tuple{Nb}, Tuple{VortexModel{Nb,Ne,isshedding} where isshedding,Union{Vortex, VortexList, Array{#s44,1} where #s44<:Vortex}}} where Ne where Nb","page":"Public Documentation","title":"GridPotentialFlow.setvortices!","text":"setvortices!(vortexmodel)\nsetvortices!(vortexmodel, newvortices)\n\n\nReplaces the vortices field of vortexmodel by a copy of newvortices.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.solvesystem!-Union{Tuple{Nb}, Tuple{GridPotentialFlow.UnregularizedPotentialFlowSolution,VortexModel{Nb,0,isshedding} where isshedding,Nodes{Dual,NX,NY,T,DT} where DT<:(AbstractArray{T,2} where T) where T<:Number where NY where NX}} where Nb","page":"Public Documentation","title":"GridPotentialFlow.solvesystem!","text":"solvesystem!(sol, vortexmodel, wphysical; parameters)\n\n\nComputes the potential flow solution sol for the bodies in vortexmodel and vorticity on the physical grid wphysical. If the vortexmodel contains bodies with regularized edges and a number of vortices which is greater than or equal to the number of regularized edges, the returned solution contains the computed strengths of the last N vortices in vortexmodel, with N the number of regularized edges. A uniform flow, body velocities, bound circulation values for the unregularized bodies, and suction parameters for regularized bodies can be specified using the parameters keyword.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.solvesystem-Union{Tuple{Nb}, Tuple{VortexModel{Nb,0,false},Nodes{Dual,NX,NY,T,DT} where DT<:(AbstractArray{T,2} where T) where T<:Number where NY where NX}} where Nb","page":"Public Documentation","title":"GridPotentialFlow.solvesystem","text":"solvesystem(vortexmodel, wphysical; kwargs...)\n\n\nComputes and returns the potential flow solution for the bodies in vortexmodel and vorticity on the physical grid wphysical. If the vortexmodel contains bodies with regularized edges and a number of vortices which is greater than or equal to the number of regularized edges, the returned solution contains the computed strengths of the last N vortices in vortexmodel, with N the number of regularized edges. A uniform flow, body velocities, bound circulation values for the unregularized bodies, and suction parameters for regularized bodies can be specified using the parameters keyword.\n\n\n\n\n\n","category":"method"},{"location":"public/#GridPotentialFlow.updateposition!-Tuple{Vortex,Real,Real,Real}","page":"Public Documentation","title":"GridPotentialFlow.updateposition!","text":"updateposition!(vortex::Vortex, u::Real, v::Real, Δt::Real) -> Vortex\n\n\nUpdates the x and y fields of vortex, given the x-velocity u, y-velocity v, and timestep Δt.\n\n\n\n\n\n","category":"method"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"EditURL = \"<unknown>/literate/5.-Generalized-edge-conditions.jl\"","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/#.-Generalized-edge-conditions","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"","category":"section"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"In the previous part, we demonstrated the means of annihilating the (nearly) singular behavior at edges on a discretized surface. In some cases, our desire is not to annihilate this behavior, but simply to keep it within some bounds. In the analytical treatment of potential flow problems, this objective is served by placing an inequality constraint on the edge suction parameter. That parameter is proportional to the coefficient on the bound vortex sheet strength's singularity, so in this discrete setting, in which we have extracted the singular part of mathfrakf in the form of mathfrakf_0, we expect the suction parameter to be related to the value of tildemathfrakf at the edge. In fact, by simple comparison, it can be shown that","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"mathfrake_k^Ttildemathfrakf = -frac2pi cGamma_0 sigma_k","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"for a flat plate of length c, where sigma_k is the suction parameter at the edge corresponding to point k.","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"Let sigma_k^mathrmmin and sigma_k^mathrmmax denote the minimum and maximum tolerable values of sigma_k at edge k. We then seek to confine the suction parameter to the range sigma_k^mathrmmin leq sigma_k leq sigma_k^mathrmmax. This generalized edge constraint is placed on the suction parameter of the intermediate sheet tildemathfrakf^*. To avoid confusion, we will redefine the bounds based on this smooth part of the vortex sheet rather than sigma_k itself; for this, we define f^mathrmmin_k = -frac2pi cGamma_0 sigma_k^mathrmmax and f^mathrmmax_k = -frac2pi cGamma_0 sigma_k^mathrmmin if Gamma_0 is positive or f^mathrmmax_k = -frac2pi cGamma_0 sigma_k^mathrmmax and f^mathrmmin_k = -frac2pi cGamma_0 sigma_k^mathrmmin if Gamma_0 is negative. Thus, we inspect whether the value mathfrake_k^Ttildemathfrakf^* lies in the range","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"f^mathrmmin_k leq mathfrake_k^Ttildemathfrakf^* leq f^mathrmmax_k","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"If mathfrake_k^Ttildemathfrakf^* lies within this range, then no new vortex is created near the edge (or equivalently, a new vortex of zero strength is created); if mathfrake_k^Ttildemathfrakf^*  f^mathrmmax_k, then we create a new vortex so that mathfrake_k^Ttildemathfrakf = f^mathrmmax_k; and if mathfrake_k^Ttildemathfrakf^*  f^mathrmmin_k, then we do the same, but now so that mathfrake_k^Ttildemathfrakf = f^mathrmmin_k. Note that the Kutta condition simply corresponds to setting f^mathrmmin_k = f^mathrmmax_k = 0.","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"Let's illustrate this again with the example of a flat plate. To clearly show the effect of varying the suction parameter, we will run a simulation of the vortex shedding for a couple of time steps for three different suction parameter ranges. First we create the grid and the flate plate.","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"using GridPotentialFlow\nusing Plots","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"Δx = 0.01\nLx = 2.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx);\nc = Lx/2 # chord length\nα = -π/3 # angle of attack\nplate = Plate(c,4*cellsize(g));\nTr = RigidTransform((0.0,0.0),α)\nTr(plate)\nΔs = dlengthmid(plate);\nnothing #hide","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"We create three instances of ModelParameters, each one with a different suction parameter range. We only vary the suction parameter at the leading edge and keep it at zero (Kutta condition) at the trailing edge.","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"σLE_list = [0.0,0.05,0.1];\nmodelparameters1 = ModelParameters(U∞=(1.0,0.0),σ=[SuctionParameter(σLE_list[1]),SuctionParameter(0.0)])\nmodelparameters2 = ModelParameters(U∞=(1.0,0.0),σ=[SuctionParameter(σLE_list[2]),SuctionParameter(0.0)])\nmodelparameters3 = ModelParameters(U∞=(1.0,0.0),σ=[SuctionParameter(σLE_list[3]),SuctionParameter(0.0)]);\nnothing #hide","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"The initial point vortices are the same.","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"Δt = 2e-2\nvLE = Vortex(plate.x[1]+3*modelparameters1.U∞[1]*Δt*plate.len*cos(plate.α+π/2),plate.y[1]+3*modelparameters1.U∞[1]*Δt*plate.len*sin(plate.α+π/2),0.0);\nvTE = Vortex(plate.x[end]+3*modelparameters1.U∞[1]*Δt*cos(α+π/2),plate.y[end]+3*Δt*modelparameters1.U∞[1]*sin(α+π/2),0.0);\nnothing #hide","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"At each time step, we will need to insert new point vortices near the regularized edges to simulate the vortex shedding. A good strategy is to place them one-third of the way from the edge to the last released vortex from that edge. This will happen at each time step, so we create a function for it.","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"function createsheddedvortices(plate,oldvortices)\n\n    vLE = Vortex(2/3*plate.x[1]+1/3*oldvortices[end-1].x,2/3*plate.y[1]+1/3*oldvortices[end-1].y,0.0)\n    vTE = Vortex(2/3*plate.x[end]+1/3*oldvortices[end].x,2/3*plate.y[end]+1/3*oldvortices[end].y,0.0)\n\n    return vLE, vTE\nend","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"We create a vortex model with the initial point vortices for each of the suction parameter ranges.","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"model1 = VortexModel(g,bodies=[plate],edges=[1,length(plate)],vortices=[vLE,vTE]);\nmodel2 = VortexModel(g,bodies=[plate],edges=[1,length(plate)],vortices=[vLE,vTE]);\nmodel3 = VortexModel(g,bodies=[plate],edges=[1,length(plate)],vortices=[vLE,vTE]);\n\nmodels = [model1,model2,model3]\nmodelparameters = [modelparameters1,modelparameters2,modelparameters3]","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"Now we can advance the solution in time.","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"T = 0:Δt:0.2\nfor t in T\n    for i in 1:length(σLE_list)\n        Ẋ = computevortexvelocities(models[i],parameters=modelparameters[i])\n        X = getvortexpositions(models[i])\n        X = X + Ẋ*Δt\n        setvortexpositions!(models[i],X)\n\n        vLE, vTE = createsheddedvortices(plate,models[i].vortices.list)\n        pushvortices!(models[i],vLE,vTE)\n    end\nend","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"By plotting the positions of the point vortices emanating from the leading edge, we see that as sigma_k^mathrmmax increases, the stream of point vortices is swept back from the edge.","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"colors = [:red,:blue,:green];\nplot(plate,fillcolor=:black,fillrange=0,fillalpha=0.25,linecolor=:black,linewidth=2,xlabel=\"x\",ylabel=\"y\")\nfor i in 1:length(models)\n    plot!(models[i].vortices.list[4:2:end],color=colors[i],marker=:circle,markersize=2)\n    plot!(models[i].vortices.list[3:2:end],color=colors[i],marker=:circle,markersize=2)\n    scatter!(models[i].vortices.list[1:2],color=colors[i],marker=:circle,markersize=2,label=\"σLE=$(σLE_list[i])\")\nend\nplot!()","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"plot(xlabel=\"body point index\",ylabel=\"f̃\")\nfor i in 1:length(σLE_list)\n    w = computew(models[i])\n    sol = solvesystem(models[i],w,parameters=modelparameters[i]);\n    plot!(sol.f./models[i].system.f₀,linecolor=colors[i],label=\"σLE=$(σLE_list[i])\")\nend\nplot!()","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"","category":"page"},{"location":"manual/5.-Generalized-edge-conditions/","page":"5. Generalized edge conditions","title":"5. Generalized edge conditions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"EditURL = \"<unknown>/literate/2.-Potential-flow-with-an-impenetrable-surface.jl\"","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/#.-Potential-flow-with-an-impenetrable-surface","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"","category":"section"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"This part introduces the treatment of rigid impenetrable surfaces in GridPotentialFlow. We can impose the no-penetration constraint by setting the fluid streamfunction equal to that of the surface mathfraks_b, up to a uniform value s_0. The discrete no-penetration constraint is thus","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"mathsfEs=mathfraks_b-mathsfE mathsfs_infty-mathfraks_0","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"where mathsfE is the interpolation operator that interpolates grid data to the surface points, \\mathsf{s}_{\\infty} is the streamfunction of the uniform flow. For a body translating at velocity (UV) and rotating at angular velocity Omega, this streamfunction would be","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"mathfraks_bk = U mathfrakr_y - V mathfrakr_x - frac12 Omega (mathfrakr_x^2+mathfrakr_y^2)","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"For later shorthand, we will denote the difference between the body motion streamfunction and interpolated uniform flow streamfunction by mathfraks_b equiv mathfraks_b - mathsfE mathsfs_infty. The no-penetration constraint is enforced in the basic potential flow problem with the help of a vector of Lagrange multipliers, mathfrakf, on the surface points. The modified potential flow problem is thus","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"mathsfLs + mathsfRmathfrakf = -mathsfw","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"where mathsfR is the regularization operator that transfers data from surface data to nodes. that mathsfE can be constructed (and we will assume it has) so that it is the transpose of the interpolation operator, mathsfE = mathsfR^T.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"From the previous equation, it is clear (by simple comparison with the vorticity on the right-hand side) that the vector mathfrakf represents the strength of the discrete bound vortex sheet on the surface. Suppose we consider the bound vortex sheet gamma(s) that emerges from the analogous continuous problem on the undiscretized surface, where s is the arc-length parameter along the surface. At each point p, the discrete solution mathfrakf is approximately equal to this continuous solution, multiplied by the length delta S_p of the small segment surrounding the point:","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"mathfrake_p^T mathfrakf approx gamma(s) delta S_p","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"Thus, the potential flow problem in the presence of the impenetrable surface is","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"beginbmatrix\nmathsfL  mathsfR \nmathsfE   0\nendbmatrix beginpmatrix mathsfs  mathfrakf endpmatrix =\nbeginpmatrix -mathsfw  mathfraks_b - mathfraks_0 endpmatrix","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"This problem has the structure of a generic saddle-point problem and we will encounter many such systems in this work. GridPotentialFlow.jl will automatically formulate the no-penetration constraint on the streamfunction and solve the saddle system when it needs to. See the next page for the role of mathfraks_0 and how it will be treated internally.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"We will now consider two examples. In these examples, we use the following grid.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"using GridPotentialFlow\nusing Plots","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"Δx = 0.03\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx);\nnothing #hide","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/#Vortex-near-a-cylinder","page":"2. Potential flow with an impenetrable surface","title":"Vortex near a cylinder","text":"","category":"section"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"As an basic example, consider now a point vortex near a circular cylinder.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"GridPotentialFlow.jl works with bodies from RigidBodyTools.jl. For our circular cylinder, we use the Circle constructor.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"Rc = Lx/4\ncircle = Circle(Rc,2*cellsize(g))\nΔs = dlength(circle);\nnothing #hide","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"We choose an initial position R_v of the vortex at 32 R_c from the origin.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"Rv = 3/2*Rc\nvortex = Vortex(Rv,0.0,1.0);\nnothing #hide","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"We construct the VortexModel by using the optional bodies keyword. In this case, we are interested in the bound vortex sheet strength mathfrakf, instead of just the streamfunction field. For this reason, we use solvesystem, which in this case returns an UnregularizedPotentialFlowSolution.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"model = VortexModel(g,vortices=[vortex],bodies=[circle]);\nw = computew(model)\nsol = solvesystem(model,w);\nnothing #hide","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"# Analytical solution (vortex at Rv and image vortex at Rc^2/Rv)\nr1 = sqrt.((circle.x.-Rv).^2 .+ (circle.y).^2) # distance from vortex to points on circle\nr2 = sqrt.((circle.x.-Rc^2/Rv).^2 .+ (circle.y).^2) # distance from image vortex to points on circle\nθ1 = π.+atan.((circle.y)./(circle.x.-Rv)) # angle from vortex to points on circle\nθ2 = atan.((circle.y),(circle.x.-Rc^2/Rv)) # angle from image vortex to points on circle\nv1x = -vortex.Γ./(2π*r1).*cos.(θ1.-π/2) # x velocity on circle induced by vortex\nv1y = -vortex.Γ./(2π*r1).*sin.(θ1.-π/2) # y velocity on circle induced by vortex\nv2x = vortex.Γ./(2π*r2).*cos.(θ2.-π/2) # x velocity on circle induced by image vortex\nv2y = vortex.Γ./(2π*r2).*sin.(θ2.-π/2) # y velocity on circle induced by image vortex\nv = sqrt.((v1x.+v2x).^2+(v1y.+v2y).^2) # velocity magnitude on circle\nγ = -v; # bound vortex sheet strength on circle (velocity on circle is clockwise if positive vortex is to the right of it)","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"We can then easily retrieve the streamfunction and the bound vortex sheet strength from the fields of the solution variable.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"plot(sol.ψ,g)\nplot!(circle,fillcolor=:black,fillrange=0,fillalpha=0.25,linecolor=:black,linewidth=2)\nscatter!([vortex.x],[vortex.y],color=:black,markersize=2,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"For this example, we can easily calculate the analytical bound vortex sheet strength gamma and compare it with our numerical solution f. See the notebook in the examples folder for the analytical solution.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"plot(sol.f./Δs,label=\"f/ds\",xlabel=\"body point index\")\nplot!(γ,label=\"gamma\")","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/#Moving-cylinder","page":"2. Potential flow with an impenetrable surface","title":"Moving cylinder","text":"","category":"section"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"In this example we will create a model with a moving body.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"Here we use the keyword parameters to solve our model with a ModelParameters variable, in which we enter a velocity for our body using the Ub keyword.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"model = VortexModel(g,bodies=[circle]);\nw = computew(model)\nmodelparameters = ModelParameters(Ub=[(1.0,0.0)])\nsol = solvesystem(model,w,parameters=modelparameters);\nnothing #hide","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"# Analytical solution\nθ = atan.(circle.y,circle.x)\nγ = 2*sin.(θ);","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"plot(sol.ψ,g)\nplot!(circle,fillcolor=:black,fillrange=0,fillalpha=0.25,linecolor=:black,linewidth=2,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"Again, we can compare the discrete bound vortex sheet strength with the analytical vortex sheet strength.","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"plot(sol.f./Δs,label=\"f/ds\",xlabel=\"body point index\")\nplot!(γ,label=\"gamma\")","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"","category":"page"},{"location":"manual/2.-Potential-flow-with-an-impenetrable-surface/","page":"2. Potential flow with an impenetrable surface","title":"2. Potential flow with an impenetrable surface","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"EditURL = \"<unknown>/literate/4.-The-Kutta-condition.jl\"","category":"page"},{"location":"manual/4.-The-Kutta-condition/#.-The-Kutta-condition","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"","category":"section"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"For surfaces that contain convex edges, the vortex sheet strength assumes a singular behavior in the vicinity of these edges, with a strength that depends on the interior angle of the edge: sharper edges have more singular behavior. In the discrete representation of the surface, edges are only approximately represented by the sudden disruptions of positions in clusters of adjacent points. The behavior in this discrete form is not quite singular, but the solution for the vortex sheet strength mathfrakf nonetheless exhibits a large and rapid change of amplitude.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Let's illustrate this with the example of a flat plate. First create the grid.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"using GridPotentialFlow\nusing Plots","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Δx = 0.01\nLx = 2.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx);\nnothing #hide","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"To create a potential flow model with flat plate, we use the Plate constructor from RigidBodyTools.jl and transform it such that its angle of attack is α.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"c = Lx/2 # chord length\nα = -π/6 # angle of attack\nplate = Plate(c,4*cellsize(g));\nTr = RigidTransform((0.0,0.0),α)\nTr(plate)\nΔs = dlengthmid(plate);\nmodel = VortexModel(g,bodies=[plate]);\nnothing #hide","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"To simulate the plate in a uniform flow, we use the U∞ keyword to construct ModelParameters","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"w = computew(model)\nmodelparameters = ModelParameters(U∞=(1.0,0.0))\nsol = solvesystem(model,w,parameters=modelparameters);\nnothing #hide","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"By plotting many streamlines, we see how flow accelerates as it tries to make its way around the sharp edges of the flat plate. In the continuous case, the velocity field would be singular at the edges.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"plot(sol.ψ,g,levels=60);\nplot!(plate,linecolor=:black,linewidth=2,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"The continous vortex sheet strength shows similar singularities at the edges, and also in our discrete case, vortex sheet strength the indeed assumes an approximate singular behavior near those edges.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"plot(sol.f,xlabel=\"body point index\",ylabel=\"f\",legend=false)","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"If we seek to eliminate this behavior, we must first have some means of exposing it. In fact, for any discretized surface, the essence of this nearly-singular behavior lies in the previously defined vector mathfrakf_0, and all other bound vortex sheets associated with the same surface share the same nearly-singular behavior. Thus, we will use a multiplicative decomposition of the vortex sheet strength:","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"mathfrakf = mathfrakf_0 circ tildemathfrakf","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"where circ is the Hadamard product. This decomposed form isolates the singular behavior into mathfrakf_0, and tildemathfrakf is a relatively smoother vector of surface point data.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"For our flat plate, we create mathfrakf_0 in the same way as we did on the previous page.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"ones = ScalarData(length(plate))\nones .= 1.0\nf₀ = model.system.S.S⁻¹*ones\nplot(f₀)","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Then we can plot the smooth tildemathfrakf as follows.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"plot(sol.f./f₀,xlabel=\"body point index\",ylabel=\"f̃\",legend=false)","category":"page"},{"location":"manual/4.-The-Kutta-condition/#Using-the-Kutta-condition-in-a-steady-state-problem","page":"4. The Kutta condition","title":"Using the Kutta condition in a steady-state problem","text":"","category":"section"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"The Kutta condition corresponds to annihilating the nearly-singular behavior at a surface point. At such points, we will set the corresponding value of tildemathfrakf to zero. Suppose we wish to enforce the Kutta condition at an edge corresponding to surface point k. The condition is","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"mathfrake_k^T tildemathfrakf = 0","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"In the regularization operation on mathfrakf, we can absorb mathfrakf_0 into mathsfR, first noting that the Hadamard product can alternatively be written with the help of a diagonal matrix,","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"mathfrakf = mathfrakf_0 circ tildemathfrakf = mathsfDmathfrakf_0 tildemathfrakf","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Then, we can define a re-scaled regularization operator,","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"mathsfRmathfrakf = mathsfR mathsfDmathfrakf_0 tildemathfrakf = tildemathsfR tildemathfrakf","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"We will first take the steady-state approach to enforce the Kutta condition: allow the bound circulation to be set appropriately, with the implicit understanding that there is a starting vortex of equal and opposite circulation at infinity that preserves the Kelvin circulation theorem. The Lagrange multiplier for this constraint will not be Gamma_b, but s_0.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"beginbmatrix\nmathsfL  tildemathsfR  0\nmathsfE   0  mathfrak1\n0  mathfrake_k^T  0\nendbmatrix beginpmatrix mathsfs  tildemathfrakf  s_0 endpmatrix =\nbeginpmatrix -mathsfw  mathfraks_b  0 endpmatrix","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"In GridPotentialFlow.jl, we create a regularized potential flow model by specifying the index of the regularized edges using the edges keyword. In this case, we want to regularize the trailing edge, which is the last point of Plate, so its index is length(plate).","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"model = VortexModel(g,bodies=[plate],edges=[length(plate)])\nw = computew(model)\nsol = solvesystem(model,w,parameters=modelparameters);\nnothing #hide","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"When there are no vortices present in the model, the package solves the above saddle point system and the solution is the steady state solution. Inspection of the streamlines shows that flow now indeed leaves the trailing edge smoothly.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"plot(sol.ψ,g);\nplot!(plate,linecolor=:black,linewidth=2,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"By plotting the vortex sheet strength, we can see that by constraining the trailing edge point of tildemathfrakf, its whole distribution is shifted upward compared to the unregularized case such that the last value equals zero.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"plot(plot(sol.f,xlabel=\"body point index\",ylabel=\"f\",legend=false),plot(sol.f./f₀,xlabel=\"body point index\",ylabel=\"f̃\",legend=false),size=[800,300])","category":"page"},{"location":"manual/4.-The-Kutta-condition/#Using-the-Kutta-condition-to-set-a-new-vortex-element","page":"4. The Kutta condition","title":"Using the Kutta condition to set a new vortex element","text":"","category":"section"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"In the previous section, we used the Kutta condition to set the bound circulation but did not explicitly create a new vortex element. This vortex element was assumed to lie at infinity so that its effect was negligible except insofar as it left equal but opposite circulation about the body.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"In this section, we will create a new vortex element in the vicinity of the edge at which we are applying the Kutta condition. We will thus seek to establish the strength of this new element and to do so in such a manner that the overall circulation of the flow is conserved. Once the element is created, it will be allowed to advect with the local fluid velocity (minus its own contribution to this velocity).","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Let us assume that the new vortex element (which we label with the subscript 1) is introduced at some point in physical space, and that its immersion into the Cartesian grid is described by a grid vector mathsfd_1 and that its strength (i.e., its circulation) is deltaGamma_1. Thus, the fluid vorticity after this new element's introduction can be written as","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"mathsfw + deltaGamma_1 mathsfd_1","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"The vector mathsfd_1 is the discrete Dirac delta function, identical (or similar) to the function that constitutes the regularization mathsfR and interpolation mathsfE matrices.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"The Kutta condition is still to be enforced. We also seek to ensure that the total circulation is zero. (We are assuming that the flow has started from rest.) Let us denote the circulation of the existing fluid vorticity mathsfw by","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Gamma_mathsfw = Delta x  mathsf1^Tmathsfw","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"where mathsf1 is a grid vector of ones. Then, the circulation constraint is","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"mathfrak1^T mathfrakf + deltaGamma_1 + Gamma_mathsfw = 0","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"The circulation of the bound vortex sheet mathfrakf can be re-written in terms of the smooth part of the sheet as mathfrak1^T mathfrakf = mathfrakf_0 tildemathfrakf.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"With these two constraints, the overall saddle point system of equations is","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"beginbmatrix\nmathsfL  tildemathsfR  0  mathsfd_1\nmathsfE   0  mathfrak1  0\n0  mathfrake_k^T  0  0\n0  mathfrakf_0^T  0  1\nendbmatrix beginpmatrix mathsfs  tildemathfrakf  s_0  deltaGamma_1 endpmatrix =\nbeginpmatrix -mathsfw  mathfraks_b  0  -Gamma_mathsfw endpmatrix","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"To simulate this case for our flat plate, we need to insert a point vortex in the flow, preferably near the trailing edge. This situation corresponds to the flow right after impulsively starting a uniform flow around a flat plate and the point vortex now represents the starting vortex. We position the vortex behind and orthogonal the plate at a distance that is proportional to the convective length from the trailing edge. This position does not matter much here, but is of importance when we step in time and insert more point vortices every time step. Its strength can be set arbitrarily, because it will be computed as part of the solution.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Δt = 1e-2\nvTE = Vortex(plate.x[end]+3*modelparameters.U∞[1]*Δt*cos(α+π/2),plate.y[end]+3*modelparameters.U∞[1]*Δt*sin(α+π/2),0.0);\nnothing #hide","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"We include the point vortex when we create our model. Because the package detects that there is a vortex in the model, it solves the unsteady saddle point system and the solution will include the strength of the point vortex. Note that if there are N edges to be regularized, the package automatically overwrites the strengths of the last N vortices in the vortices field of the model.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"model = VortexModel(g,vortices=[vTE],bodies=[plate],edges=[length(plate)])\nw = computew(model)\nsol = solvesystem(model,w,parameters=modelparameters);\nplot(sol.ψ,g);\nplot!(plate,linecolor=:black,linewidth=2)\nscatter!(model.vortices,color=:black,markersize=2,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Because of the proximity of the point vortex to the flat plate, tildemathfrakf exhibits a quick variation in its value at the surface points that lie closest to the point vortex. The value at the trailing edge point itself is still constrained to zero.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"plot(plot(sol.f,xlabel=\"body point index\",ylabel=\"f\",legend=false),plot(sol.f./f₀,xlabel=\"body point index\",ylabel=\"f̃\",legend=false),size=[800,300])","category":"page"},{"location":"manual/4.-The-Kutta-condition/#Applying-more-than-one-Kutta-condition-on-a-body","page":"4. The Kutta condition","title":"Applying more than one Kutta condition on a body","text":"","category":"section"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"Suppose we wish to enforce the Kutta condition at two edges of the body–-at points k_1 and k_2–-instead of one. Each such point has a constraint,","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"mathfrake_k_j^T tildemathfrakf = 0quad j = 12","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"For two such constraints, we need two Lagrange multipliers: the strengths of two new vortices, deltaGamma_1 and deltaGamma_2, immersed into the grid with mathsfd_1 and mathsfd_2, respectively; and we still need the Lagrange multiplier s_0 to ensure that Kelvin's circulation theorem is also enforced. The system in the previous section is thus easily generalized to the following:","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"beginbmatrix\nmathsfL  tildemathsfR  0  mathsfd_1  mathsfd_2\nmathsfE   0  mathfrak1  0 0\n0  mathfrake_k_1^T  0  0  0\n0  mathfrake_k_2^T  0  0  0\n0  mathfrakf_0^T  0  1  1\nendbmatrix beginpmatrix mathsfs  tildemathfrakf  s_0  deltaGamma_1  deltaGamma_2 endpmatrix =\nbeginpmatrix -mathsfw  mathfraks_b  0  0  -Gamma_mathsfw endpmatrix","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"We now simulate this case again for our flat plate problem. This solution corresponds to the flow right after impulsively starting a uniform flow around a flat plate, but unlike the previous case, the flow now also separates at the leading edge.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"We create two vortices, one near the leading edge and one near the trailing edge.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"vLE = Vortex(plate.x[1]+3*modelparameters.U∞[1]*Δt*plate.len*cos(plate.α+π/2),plate.y[1]+3*modelparameters.U∞[1]*Δt*plate.len*sin(plate.α+π/2),0.0);\nvTE = Vortex(plate.x[end]+3*modelparameters.U∞[1]*Δt*cos(α+π/2),plate.y[end]+3*Δt*modelparameters.U∞[1]*sin(α+π/2),0.0);\nnothing #hide","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"The model has now two regularized edges, corresponding to the first body point and the last one. Now the extended unsteady saddle point system is solved and the solution will include the strengths of the two point vortices.","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"model = VortexModel(g,vortices=[vLE,vTE],bodies=[plate],edges=[1,length(plate)]);\nw = computew(model)\nsol = solvesystem(model,w,parameters=modelparameters);\nplot(sol.ψ,g);\nplot!(plate,linecolor=:black,linewidth=2)\nscatter!(model.vortices,color=:black,markersize=2,xlabel=\"x\",ylabel=\"y\")","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"plot(plot(sol.f,xlabel=\"body point index\",ylabel=\"f\",legend=false),plot(sol.f./f₀,xlabel=\"body point index\",ylabel=\"f̃\",legend=false),size=[800,300])","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"","category":"page"},{"location":"manual/4.-The-Kutta-condition/","page":"4. The Kutta condition","title":"4. The Kutta condition","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#GridPotentialFlow.jl","page":"Home","title":"GridPotentialFlow.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A set of tools to solve potential flows past bodies on a Cartesian grid.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The objective of this package is to allow easy setup and fast simulation of potential flows. The package provides tools for","category":"page"},{"location":"","page":"Home","title":"Home","text":"constructing grids, body shapes, and point vortices,\nspecifying the relevant parameters and setting their values,\nspecifying the edges where shedding occurs and setting their suction parameter,\nsolving the problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The underlying grids are uniform and Cartesian, making use of the CartesianGrids package. This package allows the use of the lattice Green's function (LGF) for inverting the Poisson equation. The presence of bodies is accounted for using the immersed boundary projection method, originally developed for viscous flow by Taira and Colonius [1]. The potential flow system with the no-penetration condition, any edge conditions, and  Kelvin's circulation theorem is implemented with the ConstrainedSystems package. Tools for creating bodies are based on the RigidBodyTools package. The vortex dynamics are computed using the vortex-in-cell method of Christiansen [2]. For more details, please refer to Beckers, D. and Eldredge, J. D. (2021) \"Planar potential flow on Cartesian grids,\" [arXiv:2102.11910].","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: vortexshedding)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The plots in this documentation are generated using Plots.jl. You might want to install that, too, to follow the examples.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Taira, K. and Colonius, T. (2007) \"The immersed boundary method: a projection approach,\" J. Comput. Phys., 225, 2118–2137.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: Christiansen, J. (1973) \"Numerical simulation of hydrodynamics by the method of point vortices,\" J. Comput. Phys., 13, 363–379.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"EditURL = \"<unknown>/literate/6.-Force-and-the-added-mass.jl\"","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/#.-Force-and-the-added-mass","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"","category":"section"},{"location":"manual/6.-Force-and-the-added-mass/#Force","page":"6. Force and the added mass","title":"Force","text":"","category":"section"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"This part introduces the calculation of the force and moment on the body through the negative rate of change of impulse in the fluid. The continuous expressions for linear and angular impulse (about the origin) are, in two dimensions,","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"beginalign\n    boldsymbolP = int_V_f boldsymbolxtimes boldsymbolomegamathrmdV + int_S_b boldsymbolxtimes left( boldsymbolntimesboldsymbolvright)mathrmdS \n    boldsymbolPi_0 = frac12int_V_f boldsymbolxtimes left(boldsymbolxtimesboldsymbolomegaright)mathrmdV + frac12 int_S_b boldsymbolxtimes left boldsymbolxtimesleft( boldsymboln times boldsymbolv right) right mathrmdS\nendalign","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"If there is only a single body, then the force and moment (about the origin) exerted by the fluid on that body are given by","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"boldsymbolF = -rho fracmathrmdboldsymbolPmathrmdt qquad boldsymbolM_0 = -rho fracmathrmdboldsymbolPi_0mathrmdt","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"where rho is the fluid density. In the two-dimensional applications of this package, angular impulse and the moment have only a single component, e.g., boldsymbolPi_0 =Pi_0boldsymbole_z, where boldsymbole_z is the unit vector out of the plane.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/#Point-vortices-past-a-cylinder","page":"6. Force and the added mass","title":"Point vortices past a cylinder","text":"","category":"section"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"To verify our method of calculating the impulse, we create a model of two point vortices of equal and opposite circulation positioned at both sides of the x-axis, with the x-axis as axis of symmetry, and left of a circular cylinder positioned at the origin. If the top vortex has a positive circulation, the vortices propel each other towards the cylinder and convect past it. This configuration has an analytical solution for the trajecory and impulse.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"See the notebook in the examples folder for the analytical solution.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"We use a rectangular grid.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"using GridPotentialFlow\nusing Plots","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Lx = 10.0\nLy = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Ly/2,Ly/2)\ng = PhysicalGrid(xlim, ylim, 0.04)","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Rc = 1\ncircle = Circle(Rc,2*cellsize(g))\nΔs = dlength(circle);\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"The initial spacing between the vortices is y∞. After the vortices pass the cylinder, they should return to this spacing.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"y∞ = Rc/2\nv1 = Vortex(-Lx/2+10*cellsize(g),y∞,1.0);\nv2 = Vortex(-Lx/2+10*cellsize(g),-y∞,-1.0);\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"We create the vortex model with these two point vortices and the circle and advance the position of the point vortices over some time. During the time stepping, we compute the impulse with computeimpulse and store its history.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"model = VortexModel(g,bodies=[circle],vortices=[v1,v2])\nw = computew(model)\nsol = solvesystem(model,w);\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"# Analytical trajectory\nx(r) = sqrt(r^2-(y∞^2*(r^2-1)^2)/((r^2-1)^2-4*y∞^2))\ny(r) = y∞*(r^2-1)/sqrt((r^2-1)^2-4*y∞^2)\ns = 0:0.001:π/2\nrmin = 1.4375649\nc1 = rmin/(-Lx/2+rmin)\nc2 = -Lx/2*c1\nr = c2 ./ (cos.(s).-c1)\nx_trajectory = -reverse(x.(r)); append!(x_trajectory,x.(r))\ny_trajectory_upper = reverse(y.(r)); append!(y_trajectory_upper,y.(r))\ny_trajectory_lower = -y_trajectory_upper;\n# Analytical impulse\nPx_func(x,y) = y - y/(x^2+y^2) + y - y/(x^2+y^2);\nPy_func(x,y) = -x + x/(x^2+y^2) + x - x/(x^2+y^2);\nPx_exact = Px_func.(x_trajectory,y_trajectory_upper);\nPy_exact = Py_func.(x_trajectory,y_trajectory_upper);","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Δt = 0.1\nT = 0:Δt:64.0\nX_hist = []\nPx_numerical_hist = []\nPy_numerical_hist = []\n\nfor t in T\n    Ẋ = computevortexvelocities(model)\n    X = getvortexpositions(model)\n    X = X + Ẋ*Δt\n    setvortexpositions!(model,X)\n\n    push!(X_hist,X)\n\n    Px, Py = computeimpulse(model)\n    push!(Px_numerical_hist,Px)\n    push!(Py_numerical_hist,Py)\nend","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"When we compare the trajectories and impulse history, the numerical and anaylytical solution should match closely, which is indeed the case.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"plot(circle,fillcolor=:black,fillrange=0,fillalpha=0.25,linecolor=:black,linewidth=2,xlabel=\"x\",ylabel=\"y\")\nscatter!(model.vortices,color=:red)\nplot!(x_trajectory,y_trajectory_upper,linecolor=:red,label=\"exact\")\nplot!(x_trajectory,y_trajectory_lower,linecolor=:red,label=\"\")\nplot!((X->X[1]).(X_hist),(X->X[3]).(X_hist),color=:blue,linestyle=:dash,label=\"simulated\")\nplot!((X->X[2]).(X_hist),(X->X[4]).(X_hist),color=:blue,linestyle=:dash,label=\"\")","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"plot(x_trajectory,Px_exact,color=:red,label=\"exact\",xlabel=\"x\",ylabel=\"Px\")\nplot!((X->X[1]).(X_hist),Px_numerical_hist,color=:blue,linestyle=:dash,label=\"simulated\")","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/#Flat-plate","page":"6. Force and the added mass","title":"Flat plate","text":"","category":"section"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"We can apply this method also to our flat plate example and compare it to the Biot-Savart method from the PotentialFlow.jl package.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"See the notebook in the examples folder for the Biot-Savart solution.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Because we create the PotentialFlow.jl model with a moving plate instead of a uniform flow, we specify a translational velocity. The GridPotentialFlow.jl model will still use a moving body coordinate system and thus a uniform flow that equals the negative translational velocity.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"c = 1.0;   # chord length\n\nċ = -1.0;  # translational velocity\nα = -π/3;   # angle of attack\n\nσLE = 0.0;\nσTE = 0.0;\n\nΔt = 5e-2;\ntf = 1.0;\nT = 0.0:Δt:tf;\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"# Potential Flow\nusing PotentialFlow\nfunction compute_ẋ!(ẋ, x, t)\n    plate, ambient_sys = x\n    motion = ẋ[1]\n    motion.ċ, motion.c̈, motion.α̇ = motion.kin(t)\n    Plates.enforce_no_flow_through!(plate, motion, ambient_sys, t)\n    reset_velocity!(ẋ, x)\n    self_induce_velocity!(ẋ, x, t)\nend\nfunction shed_new_vorticity!(blobs, plate, motion, t, lesp = 0.0, tesp = 0.0)\n    z₊ = (blobs[end-1].z + 2plate.zs[end])/3\n    z₋ = (blobs[end].z + 2plate.zs[1])/3\n\n    blob₊ = PotentialFlow.Vortex.Blob(z₊, 1.0, δ)\n    blob₋ = PotentialFlow.Vortex.Blob(z₋, 1.0, δ)\n    Plates.enforce_no_flow_through!(plate, motion, blobs, t)\n\n    Γ₊, Γ₋, _, _ = Plates.vorticity_flux!(plate, blob₊, blob₋, t, lesp, tesp);\n    push!(blobs, PotentialFlow.Vortex.Blob(z₊, Γ₊, blobs[1].δ), PotentialFlow.Vortex.Blob(z₋, Γ₋, blobs[1].δ))\nend\nN = 128 # number of plate control points (distributed along a extrema Chebyshev grid)\nδ = 0.01\nplate = PotentialFlow.Plate(N, c, zero(ComplexF64), α)\nmotion = Plates.RigidBodyMotion(ċ, 0.0);\n# Initial step\nΔz₀ = im*3Δt*exp(im*plate.α) # vectors perpendicular to the plate\nz₋, z₊ = plate.zs[[1,N]] # LE and TE\nblobs = PotentialFlow.Vortex.Blob.(Δz₀ .+ [z₊, z₋], 1.0, δ) # First two point vortices are placed close to the LE and TE with unit strength\nPlates.enforce_no_flow_through!(plate, motion, (), 0)\nΓ₊, Γ₋, _, _ = Plates.vorticity_flux!(plate, blobs[1], blobs[2], 0.0, σLE, σTE); # Determine strength of first two vortices\nblobs = PotentialFlow.Vortex.Blob.(Δz₀ .+ [z₊, z₋], [Γ₊, Γ₋], δ) # Create first two point vortices now with calculated strengths\nsys₀ = (plate, blobs)\nsys = deepcopy(sys₀)\nsys₊ = deepcopy(sys₀) # Used for storage during time-marching\nẋs = (motion, allocate_velocity(blobs))\nimp = ComplexF64[];\nt_hist = Float64[]\nt = 0\npush!(t_hist,t)\npush!(imp,Elements.impulse(sys));\n# Time stepping\nfor tloc in T[2:end]\n    global t += Δt\n    global sys\n    global sys₊\n    push!(t_hist,t)\n    plate, ambient_ω = sys\n    motion, ambient_u = ẋs\n    resize!(sys₊[2], length(sys[2]))\n    forward_euler!(sys₊, sys, t, Δt, compute_ẋ!, advect!, ẋs)\n    # The force requires information about the motion of the plate,\n    # the strength, location, and velocity of the ambient vortex elements,\n    # as well as the vorticity flux from the plate edges\n    sys, sys₊ = sys₊, sys\n    shed_new_vorticity!(sys[2], sys[1], ẋs[1], t, σLE, σTE)\n    push!(imp,Elements.impulse(sys))\nend\nforce = -diff(imp)/Δt;","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Δx = 0.01\nxlim = (-0.5,2)\nylim = (-1,1)\ng = PhysicalGrid(xlim,ylim,Δx);\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"dsdx = 2\nplate = RigidBodyTools.Plate(c,dsdx*Δx)\ntransform = RigidTransform((0.0,0.0),-π/3)\ntransform(plate);\nΔs = dlength(plate)\nmaximum(Δs/Δx);\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"As before, we create the initial vortices based on the time step and uniform flow and define a function that create the new point vortices for the subsequent time steps.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"firstvLE = GridPotentialFlow.Vortex(plate.x[1]+3Δt*(-ċ)*cos(plate.α+π/2),plate.y[1]+3Δt*(-ċ)*sin(plate.α+π/2),0.0);\nfirstvTE = GridPotentialFlow.Vortex(plate.x[end]+3Δt*(-ċ)*cos(plate.α+π/2),plate.y[end]+3Δt*(-ċ)*sin(plate.α+π/2),0.0);\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"function createsheddedvortices(plate,oldvortices)\n\n    vLE = GridPotentialFlow.Vortex(2/3*plate.x[1]+1/3*oldvortices[end-1].x,2/3*plate.y[1]+1/3*oldvortices[end-1].y,0.0)\n    vTE = GridPotentialFlow.Vortex(2/3*plate.x[end]+1/3*oldvortices[end].x,2/3*plate.y[end]+1/3*oldvortices[end].y,0.0)\n\n    return vLE,vTE\nend","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"The model parameters should specify the uniform velocity as the negative translational velocity of the plate.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"model = VortexModel(g,bodies=[plate],edges=[1,length(plate)],vortices=[firstvLE,firstvTE]);\nmodelparameters = ModelParameters(U∞=(-ċ,0.0),σ=[SuctionParameter(σLE),SuctionParameter(σTE)]);\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"The first impulse we record is with the first two vortices. Note that the computeimpulse function internally calls the solvesystem method so it sets the strengths of the new vortices and such that they are correctly accounted for in the impulse calculation.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Px_hist = Float64[];\nPy_hist = Float64[];\nPx, Py = computeimpulse(model,parameters=modelparameters);\npush!(Px_hist,Px);\npush!(Py_hist,Py);\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Then we enter a time loop and record the impulse every time we create new vortices.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"for tloc in T[2:end]\n    Ẋ = computevortexvelocities(model,parameters=modelparameters)\n    X = getvortexpositions(model)\n    X = X + Ẋ*Δt\n    setvortexpositions!(model,X)\n\n    vLE, vTE = createsheddedvortices(plate,model.vortices.list)\n    pushvortices!(model,vLE,vTE)\n\n    Px, Py = computeimpulse(model,parameters=modelparameters)\n    push!(Px_hist,Px)\n    push!(Py_hist,Py)\nend","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"The force history can be obtained by finite differencing the impulse history.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Fx_hist = -diff(Px_hist)/Δt;\nFy_hist = -diff(Py_hist)/Δt;\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"We can now compare the positions of the point vortices by shifting the PotentialFlow.jl solution by -tf*ċ such that the origin of the frame of reference coincides with the center plate. Superimposingt the GridPotentialFlow.jl solution then shows that the positions of the point vortices agree very well.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"plot(plate,fillcolor=:black,fillrange=0,fillalpha=0.25,linecolor=:black,linewidth=2,xlim=xlim,ylim=ylim,xlabel=\"x\",ylabel=\"y\")\nscatter!(real.((v->v.z).(sys[2])).-tf*ċ,imag.((v->v.z).(sys[2])),color=:red,markersize=4,label=\"PotentialFlow.jl\")\nscatter!(model.vortices,color=:blue,markersize=2,label=\"GridPotentialFlow.jl\")","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"The vertical impulse and the vertical force (lift) can also be compared and show good agreement as well.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"plot(xlabel=\"t\",ylabel=\"Py\")\nplot!(T,Py_hist,color=:blue,label=\"PotentialFlow.jl\")\nplot!(T,imag.(imp),color=:red,label=\"GridPotentialFlow.jl\")","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"plot(xlabel=\"t\",ylabel=\"Fy\")\nplot!(T[2:end],Fy_hist,color=:blue,label=\"PotentialFlow.jl\")\nplot!(T[2:end],imag.(force),color=:red,label=\"GridPotentialFlow.jl\")","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/#Added-mass","page":"6. Force and the added mass","title":"Added mass","text":"","category":"section"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"The added mass tensor provides a measure of the inertial influence of the fluid on the body in response to changes in the body's translational or rotational motion. The coefficients of the added mass tensor of a body are obtained by computing the impulse components associated with a unit-valued component of motion. The motion's influence is both direct, via the surface velocity, and indirect, in the bound vortex sheet that develops on the surface.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"The added mass for simple geometries can easiliy be calculated in an analytical way. For example, the entries of the translational added mass tensor for an ellipse with semi-major axis a and semi-minor axis b are m_xx = rho pi b^2 for motion in the x direction, m_yy = rho pi a^2 for motion in the y-direction, with the diagonal entries m_xy=m_yx=0. By using computeaddedmassmatrix from this package we can approximate these results numerically. In this case, we have one body and the method will return a matrix with the entries","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"beginbmatrix\nm_xx  m_xy \nm_yx  m_yy\nendbmatrix","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"Lx = 2.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,0.01)\nΔx = cellsize(g);","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"a = 0.5\nb = 0.25\nellipse = Ellipse(a,b,Δx)\nmodel = VortexModel(g,bodies=[ellipse])\nM = computeaddedmassmatrix(model)","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"We can compare the values using the @test macro.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"using Test\n@test isapprox(M[1,1], π*b^2, rtol=1e-1)","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"@test isapprox(M[2,2], π*a^2, atol=1e-1)","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"In the case of N bodies, computeaddedmassmatrix returns the translational added mass tensor of size 2N-by-2N. As an example, we will compute the added mass tensor for an array of cylinders. To compare it with an analytically obtained solution, we will calculate the added mass matrix tensor for the following gap-to-radius ratios.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"GRratios = [0.1,0.2,0.3,0.4,0.5,0.6,0.8,1.0,1.2,1.4,1.6];\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"function rectangulararray(rows,columns,spacing)\n    centers = VectorData(rows*columns)\n    for j in 1:columns\n        for i in 1:rows\n            xc = (i-1)*spacing\n            yc = (j-1)*spacing\n            centers.u[(j-1)*rows+i] = xc\n            centers.v[(j-1)*rows+i] = yc\n        end\n    end\n    centers.u .-= mean(centers.u)\n    centers.v .-= mean(centers.v)\n    return centers\nend","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"For this case, the array consists of three rows of three cylinders.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"n = 100\nrows = 3\ncolumns = 3\nN = rows*columns\nR = 0.20\n𝒱 = π*R^2\nbodies = fill(Circle(R,2*cellsize(g)),N);\nΔs = minimum(dlength(bodies[1]));\nnothing #hide","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"We loop over the gap-to-radius ratios, position the bodies, and compute the ratio of the largest eigenvalue to the largest diagonal element of the translational added mass tensor. To position the bodies, we defined the method rectangulararray (see notebook in the examples folder).","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"using Statistics: mean\nusing LinearAlgebra: eigen","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"λoverMratios = zeros(length(GRratios))\nfor idx in 1:length(GRratios)\n    global bodies\n    gap = GRratios[idx]*R\n    spacing = 2*R+gap\n    bodycenters = rectangulararray(rows,columns,spacing)\n    for i in 1:N\n        T = RigidTransform((bodycenters.u[i],bodycenters.v[i]),0.0)\n        global bodies[i] = T(deepcopy(bodies[i]))\n    end\n    bodylist = BodyList(bodies)\n    model = VortexModel(g,bodies=bodylist);\n    M = computeaddedmassmatrix(model)/𝒱\n    eigM = eigen(M);\n    max_eig_value_coef = maximum(real(eigM.values))\n    max_self_added_mass_coef = maximum(M)\n    λoverMratios[idx] = max_eig_value_coef/max_self_added_mass_coef\nend","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"The same ratios, obtained in an analytical way, are available in literature [1] and can be used to verify the numerical values.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"nineRodArrayChen = [2.3637,2.2092,2.1007,2.0120,1.9350,1.8665,1.7494,1.6531,1.5732,1.5066,1.4508];\nplot(xlabel=\"GR\",ylabel=\"λ/max(Mij)\")\nplot!(GRratios,nineRodArrayChen,label=\"Chen1975\")\nplot!(GRratios,λoverMratios,label=\"GridPotentialFlow.jl\")","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"[1]: Chen, S. S. (1975) \"Vibration of nuclear fuel bundles,\" Nuclear Engineering and Design, 35 (3), 399-–422.","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"","category":"page"},{"location":"manual/6.-Force-and-the-added-mass/","page":"6. Force and the added mass","title":"6. Force and the added mass","text":"This page was generated using Literate.jl.","category":"page"}]
}
